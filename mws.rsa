Routines

%webINI5
%webINI5 ; ; 22-JAN-2019
 ;;1.0;MUMPS WEB SERVER;;JAN 22, 2019
 K ^UTILITY("DIF",$J) S DIFRDIFI=1 F I=1:1:2 S ^UTILITY("DIF",$J,DIFRDIFI)=$T(IXF+I),DIFRDIFI=DIFRDIFI+1
 Q
IXF ;;
 ;;17.6001S;WEB SERVICE URL HANDLER;^%web(17.6001,;0;y;y;;n;;;n
 ;;

%webINI1
%webINI1 ; ;Feb 07, 2019@11:08
 ;;1.0;MUMPS WEB SERVER;;JAN 22, 2019
 ; LOADS AND INDEXES DD'S
 ;
 ; Copyright 2013-2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.
 ;
 K DIF,DIK,D,DDF,DDT,DTO,D0,DLAYGO,DIC,DIDUZ,DIR,DA,DFR,DTN,DIX,DZ D DT^DICRW S %=1,U="^",DSEC=1
 S NO=$P("I 0^I $D(@X)#2,X[U",U,%) I %<1 K DIFQ Q
ASK I %=1,$D(DIFQ(0)) ; W !,"SHALL I WRITE OVER FILE SECURITY CODES" S %=2 D YN^DICN S DSEC=%=1 I %<1 K DIFQ Q
 Q:'$D(DIFQ)  ; S %=2 W !!,"ARE YOU SURE EVERYTHING'S OK" D YN^DICN I %-1 K DIFQ Q
 I $D(DIFKEP) F DIDIU=0:0 S DIDIU=$O(DIFKEP(DIDIU)) Q:DIDIU'>0  S DIU=DIDIU,DIU(0)=DIFKEP(DIDIU) D EN^DIU2
 D DT^DICRW K ^UTILITY(U,$J),^UTILITY("DIK",$J) D WAIT^DICD
 S DN="^%webI" F R=1:1:2 D @(DN_$$B36(R)) W "."
 F  S D=$O(^UTILITY(U,$J,"SBF","")) Q:D'>0  K:'DIFQ(D) ^(D) S D=$O(^(D,"")) I D>0  K ^(D) D IX
KEYSNIX ; Keys and new style indexes installer ; new in FM V22.2
 N DIFRSA S DIFRSA=$NA(^UTILITY("KX",$J)) ; Tran global for Keys and Indexes
 N DIFRFILE S DIFRFILE=0 ; Loop through files
 F  S DIFRFILE=$O(@DIFRSA@("IX",DIFRFILE)) Q:'DIFRFILE  D
 . K ^TMP("DIFROMS2",$J,"TRIG")
 . N DIFRD S DIFRD=0
 . F  S DIFRD=$O(@DIFRSA@("IX",DIFRFILE,DIFRD)) Q:'DIFRD  D DDIXIN^DIFROMSX(DIFRFILE,DIFRD,DIFRSA) ; install New Style Indexes
 . K ^TMP("DIFROMS2",$J,"TRIG")
 . S DIFRD=0
 . F  S DIFRD=$O(@DIFRSA@("KEY",DIFRFILE,DIFRD)) Q:'DIFRD  D DDKEYIN^DIFROMSY(DIFRFILE,DIFRD,DIFRSA) ; install keys
 K @DIFRSA ; kill off tran global
 ; VEN/SMH v22.2: Below I added a K D1 because it leaks from the call causing the key matching algo to fail.
DATA W "." S (D,DDF(1),DDT(0))=$O(^UTILITY(U,$J,0)) Q:D'>0
 I DIFQR(D) S DTO=0,DMRG=1,DTO(0)=^(D),Z=^(D)_"0)",D0=^(D,0),@Z=D0,DFR(1)="^UTILITY(U,$J,DDF(1),D0,",DKP=DIFQR(D)'=2 F D0=0:0 S D0=$O(^UTILITY(U,$J,DDF(1),D0)) S:D0="" D0=-1 K D1 Q:'$D(^(D0,0))  S Z=^(0) D I^DITR
 K ^UTILITY(U,$J,DDF(1)),DDF,DDT,DTO,DFR,DFN,DTN G DATA
 ;
W S Y=$P($T(@X),";",2) W !,"NOTE: This package also contains "_Y_"S",! Q:'$D(DIFQ(0))
 S %=1 W ?6,"SHALL I WRITE OVER EXISTING "_Y_"S OF THE SAME NAME" D YN^DICN I '% W !?6,"Answer YES to replace the current "_Y_"S with the incoming ones." G W
 S:%=2 DIFQ(X)=0 K:%<0 DIFQ
 Q
 ;
OPT ;OPTION
RTN ;ROUTINE DOCUMENTATION NOTE
FUN ;FUNCTION
BUL ;BULLETIN
KEY ;SECURITY KEY
HEL ;HELP FRAME
DIP ;PRINT TEMPLATE
DIE ;INPUT TEMPLATE
DIB ;SORT TEMPLATE
DIS ;FORM
REM ;REMOTE PROCEDURE
 ;
SBF ;FILE AND SUB FILE NUMBERS
IX W "." S DIK="A" F %=0:0 S DIK=$O(^DD(D,DIK)) Q:DIK=""  K ^(DIK)
 S DA(1)=D,DIK="^DD("_D_"," D IXALL^DIK
 I $D(^DIC(D,"%",0)) S DIK="^DIC(D,""%""," G IXALL^DIK
 Q
B36(X) Q $$N(X\(36*36)#36+1)_$$N(X\36#36+1)_$$N(X#36+1)
N(%) Q $E("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",%)

%webINI2
%webINI2 ; ; 22-JAN-2019
 ;;1.0;MUMPS WEB SERVER;;JAN 22, 2019
 ;
 ;
 K ^UTILITY("DIFROM",$J),DIC S DIDUZ=0 S:$D(DUZ)#2 DIDUZ=DUZ S DUZ=.5
 I $D(^DIC(9.2,0))#2,^(0)?1"HEL".E S (DIC,DLAYGO)=9.2,N="HEL",DIC(0)="LX" G ADD
 Q
 ;
ADD F R=0:0 S R=$O(^UTILITY(U,$J,N,R)) Q:R'>0  S X=$P(^(R,0),U,1) W "." K DA D ^DIC I Y>0,'$D(DIFQ(N))!$P(Y,U,3) S ^UTILITY("DIFROM",$J,N,X)=+Y K ^DIC(9.2,+Y,1),^(2),^(3),^(10) S %X="^UTILITY(U,$J,N,R,",%Y=DIC_"+Y,",DA=+Y D %XY^%RCR
 S DIK=DIC
HELP S R=$O(^UTILITY("DIFROM",$J,N,R)) Q:R=""  W !,"'"_R_"' Help Frame filed." S DA=^(R)
 F X=0:0 S X=$O(^DIC(9.2,DA,2,X)) Q:'X  S I=$S($D(^(X,0)):^(0),1:0),Y=$P(I,U,2) S:Y]"" Y=$O(^DIC(9.2,"B",Y,0)) S ^(0)=$P(^DIC(9.2,DA,2,X,0),U,1)_U_$S(Y>0:Y,1:"")_U_$P(^(0),U,3,99)
 S I=0 F X=0:0 S X=$O(^DIC(9.2,DA,10,X)) Q:'X  I $D(^(X,0)) S Y=$P(^(0),U),Y=$S(Y]"":$O(^MAG("B",Y,0)),1:0) S:Y $P(^DIC(9.2,DA,10,X,0),U)=Y,I=I+1,%=X I 'Y K ^DIC(9.2,DA,10,X,0)
 I I S $P(^DIC(9.2,DA,10,0),U,3,4)=%_U_I
IX D IX1^DIK G HELP
 ;
U I $D(DIRUT) S DIFQ=1
 W ! Q
REP S DIR(0)="Y",DIR("A")="Shall I change the NAME of the file to "_DIF
 S DIR("??")="^D REP^DIFROMH1",DIR("B")="NO" D ^DIR G U:$D(DIRUT)
 I Y S DIE=1,DIFQ=0,DA=N,DR=".01////"_DIF D ^DIE Q
 S DIR("A")="Shall I replace your file with mine"
 S DIR("??")="^D AG^DIFROMH1" D ^DIR G U:$D(DIRUT)!'Y
 S DIU(0)="E",DIR("A")="Do you want to keep the Data"
 S DIR("??")="^D CHG^DIFROMH1" D ^DIR G U:$D(DIRUT)
 S:'Y DIU(0)=DIU(0)_"D"
 S DIR("A")="Do you want to keep the Templates"
 S DIR("??")="^D TEMP^DIFROMH1" D ^DIR G U:$D(DIRUT) S:'Y DIU(0)=DIU(0)_"T"
 S DIFQ(N)=1,DIFKEP(N)=DIU(0) W !?15," (",DIF,") " Q

%webINIT
%webINIT ; ;Feb 07, 2019@11:09
 ;;1.0;MUMPS WEB SERVER;;JAN 22, 2019
 ;
 ; Copyright 2013-2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.
 ;
 K DIF,DIFQ,DIFQR,DIFQN,DIK,DDF,DDT,DTO,D0,DLAYGO,DIC,DIDUZ,DIR,DA,DIFROM,DFR,DTN,DIX,DZ,DIRUT,DTOUT,DUOUT
 S DIOVRD=1,U="^",DIFQ=0,DIFROM="1.0" W !,"This version (#1.0) of '%webINIT' was created on 22-JAN-2019"
 W !?9,"(at DEMO.OSEHRA.ORG, by MSC FileMan 22.1061)",!
 I $D(^DD("VERSION")),^("VERSION")'<22.0 G GO
 ;W !,"FIRST, I'LL FRESHEN UP YOUR VA FILEMAN...." D N^DINIT
 I ^DD("VERSION")<22.2 W !,"but I need version 22.2 of the VA FileMan!" G Q
GO ;
EN ; ENTER HERE TO BYPASS THE PRE-INIT PROGRAM
 S DIFQ=0 K DIRUT,DTOUT,DUOUT
 F DIFRIR=1:1:1 S DIFRRTN="^%webINI"_$E("5",DIFRIR) D @DIFRRTN
 W:1 !,"I AM GOING TO SET UP THE FOLLOWING FILES:" F I=1:2:2 S DIF(I)=^UTILITY("DIF",$J,I) D 1 G Q:DIFQ!$D(DIRUT) K DIF(I)
 S DIFROM="1.0" D PKG:'$D(DIFROM(0)),^%webINI1 G Q:'$D(DIFQ) S DIK(0)="AB"
 F DIF=1:2:2 S %=^UTILITY("DIF",$J,DIF),DIK=$P(%,";",5),N=$P(%,";",3),D=$P(%,";",4)_U_N D D K DIFQ(N)
 K DIFQR D ^%webINI2,^%webINI3
 L  S DUZ=DIDUZ W:1 !,$C(7),"OK, I'M DONE.",!,"NO"_$P("TE THAT FILE",U,DSEC)_" SECURITY-CODE PROTECTION HAS BEEN MADE"
 I DIFROM F DIF=1:2:2 S %=^UTILITY("DIF",$J,DIF),N=+$P(%,";",3) I N,$P(%,";",8)="y" S ^DD(N,0,"VR")=DIFROM
 I DIFROM(0)>0 F %="PRE","INI","INIT" S:$D(DIFROM(%)) $P(^DIC(9.4,DIFROM(0),%),U,2)=DIFROM(%)
 I $G(DIFQN) S $P(^(0),U,3,4)=$P(DIFQN,U,2)_U_($P(^DIC(0),U,4)+DIFQN) K DIFQN
 S:DIFROM(0)>0 ^DIC(9.4,DIFROM(0),"VERSION")=DIFROM G Q^DIFROM0
D S:$D(^DIC(+N,0))[0 ^(0)=D S X=$D(@(DIK_"0)")),^(0)=D_U_$S(X#2:$P(^(0),U,3,9),1:U)
 S DIFQR=DIFQR(+N) I ^DD("VERSION")>17.5,$D(^DD(+N,0,"DIK"))#2 S X=^("DIK"),Y=+N,DMAX=^DD("ROU") D EN^DIKZ
 I DIFQR D IXALL^DIK:$O(@(DIK_"0)")) W "."
 Q
R G REP^%webINI2
 ;
1 S N=+$P(DIF(I),";",3),DIF=$P(DIF(I),";",4),S=$P(DIF(I),";",5)
 W !!?3,N,?13,DIF,$P("  (Partial Definition)",U,$P(DIF(I),";",6)),$P("  (including data)",U,$P(DIF(I),";",13)="y") S Z=$S($D(^DIC(N,0))#2:^(0),1:"")
 I Z="" S DIFQ(N)=1,DIFQN=$G(DIFQN)+1_U_N G S
 I $L($P(Z,DIF)) W $C(7),!,"*BUT YOU ALREADY HAVE '",$P(Z,U),"' AS FILE #",N,"!" D R Q:DIFQ  G S:$D(DIFKEP(N)),1
 S DIFQ(N)=$P(DIF(I),";",7)'="n"
 I $L(Z) W $C(7),!,"Note:  You already have the '",$P(Z,U),"' File." S DIFQ(0)=1
 S %=$E(^UTILITY("DIF",$J,I+1),4,245) I %]"" X % S DIFQ(N)=$T W:'$T !,"Screen on this Data Dictionary did not pass--DD will not be installed!" G S
 I $L(Z),$P(DIF(I),";",10)="y" S DIR("A")="Shall I write over the existing Data Definition",DIR("??")="^D DD^DIFROMH1",DIR("B")="YES",DIR(0)="Y" D ^DIR S DIFQ(N)=Y
S S DIFQR(N)=0 Q:$P(DIF(I),";",13)'="y"!$D(DIRUT)
 I $P(DIF(I),";",15)="y",$O(@(S_"0)"))>0 S DIF=$P(DIF(I),";",14)="o",DIR("A")="Want my data "_$P("merged with^to overwrite",U,DIF+1)_" yours",DIR("??")="^D DTA^DIFROMH1",DIR(0)="Y" D ^DIR S DIFQR(N)=$S('Y:Y,1:Y+DIF) Q
 S %=$P(DIF(I),";",14)="o" W !,$C(7),"I will ",$P("MERGE^OVERWRITE",U,%+1)," your data with mine." S DIFQR(N)=%+1
 Q
Q W $C(7),!!,"NO UPDATING HAS OCCURRED!" G Q^DIFROM0
 ;
PKG S X=$P($T(IXF),";",3),DIC="^DIC(9.4,",DIC(0)="",DIC("S")="I $P(^(0),U,2)="""_$P(X,U,2)_"""",X=$P(X,U) D ^DIC S DIFROM(0)=+Y K DIC
 Q
 ;
IXF ;;;1

%webI001
%webI001 ; ;2019-08-12  4:52 PM
 ;;1.0;MUMPS WEB SERVER;;JAN 22, 2019
 Q:'DIFQ(17.6001)  F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,999) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^DIC(17.6001,0,"GL")
 ;;=^%web(17.6001,
 ;;^DIC("B","WEB SERVICE URL HANDLER",17.6001)
 ;;=
 ;;^DD(17.6001,0)
 ;;=FIELD^^20^8
 ;;^DD(17.6001,0,"DT")
 ;;=3190121
 ;;^DD(17.6001,0,"NM","WEB SERVICE URL HANDLER")
 ;;=
 ;;^DD(17.6001,.01,0)
 ;;=HTTP VERB^RS^POST:POST;PUT:PUT;GET:GET;DELETE:DELETE;TRACE:TRACE;CONNECT:CONNECT;^0;1^Q
 ;;^DD(17.6001,.01,1,0)
 ;;=^.1^^0
 ;;^DD(17.6001,.01,3)
 ;;=
 ;;^DD(17.6001,.01,"DT")
 ;;=3190117
 ;;^DD(17.6001,1,0)
 ;;=URI^F^^1;E1,250^K:$L(X)>250!($L(X)<1) X
 ;;^DD(17.6001,1,3)
 ;;=
 ;;^DD(17.6001,1,"DT")
 ;;=3190117
 ;;^DD(17.6001,2,0)
 ;;=EXECUTION ENDPOINT^F^^2;E1,250^K:$L(X)>250!($L(X)<1) X
 ;;^DD(17.6001,2,3)
 ;;=
 ;;^DD(17.6001,2,"DT")
 ;;=3190117
 ;;^DD(17.6001,11,0)
 ;;=AUTHENTICATION REQUIRED?^S^1:YES;^AUTH;1^Q
 ;;^DD(17.6001,11,"DT")
 ;;=3130506
 ;;^DD(17.6001,12,0)
 ;;=KEY^P19.1'^DIC(19.1,^AUTH;2^Q
 ;;^DD(17.6001,12,"DT")
 ;;=3130506
 ;;^DD(17.6001,13,0)
 ;;=REVERSE KEY^P19.1'^DIC(19.1,^AUTH;3^Q
 ;;^DD(17.6001,13,"DT")
 ;;=3130507
 ;;^DD(17.6001,14,0)
 ;;=OPTION^P19'^DIC(19,^AUTH;4^Q
 ;;^DD(17.6001,14,"DT")
 ;;=3130506
 ;;^DD(17.6001,20,0)
 ;;=PARAMETERS^17.60012S^^PARAMS;0
 ;;^DD(17.60012,0)
 ;;=PARAMETERS SUB-FIELD^^.001^3
 ;;^DD(17.60012,0,"DT")
 ;;=3190121
 ;;^DD(17.60012,0,"NM","PARAMETERS")
 ;;=
 ;;^DD(17.60012,0,"UP")
 ;;=17.6001
 ;;^DD(17.60012,.001,0)
 ;;=NUMBER^NJ2,0^^ ^K:+X'=X!(X>50)!(X<1)!(X?.E1"."1N.N) X
 ;;^DD(17.60012,.001,3)
 ;;=Type a number between 1 and 50, 0 decimal digits.
 ;;^DD(17.60012,.001,21,0)
 ;;=^^1^1^3190121^
 ;;^DD(17.60012,.001,21,1,0)
 ;;=Order of the Parameter to be passed.
 ;;^DD(17.60012,.001,"DT")
 ;;=3190121
 ;;^DD(17.60012,.01,0)
 ;;=PARAMETER TYPE^MS^Q:HTTP QUERY;F:URL ENCODED FORM;B:BODY;H:HEADER;U:URL COMPONENT;^0;1^Q
 ;;^DD(17.60012,.01,1,0)
 ;;=^.1^^0
 ;;^DD(17.60012,.01,3)
 ;;=Enter a parameter type.
 ;;^DD(17.60012,.01,21,0)
 ;;=^.001^2^2^3190121^^
 ;;^DD(17.60012,.01,21,1,0)
 ;;=This field allows you to add parameters that get called to your routine 
 ;;^DD(17.60012,.01,21,2,0)
 ;;=rather than everything going into ARGS and the rest into BODY.
 ;;^DD(17.60012,.01,"DT")
 ;;=3190121
 ;;^DD(17.60012,.02,0)
 ;;=PARAMETER NAME^FJ16^^0;2^K:$L(X)>16!($L(X)<1) X
 ;;^DD(17.60012,.02,3)
 ;;=Answer must be 1-16 characters in length.
 ;;^DD(17.60012,.02,21,0)
 ;;=^^4^4^3190117^
 ;;^DD(17.60012,.02,21,1,0)
 ;;=This field contains the parameter name for headers, form fields, and HTTP 
 ;;^DD(17.60012,.02,21,2,0)
 ;;=Query parameters. For example, if you pass a=12&b=22 as an HTTP query,
 ;;^DD(17.60012,.02,21,3,0)
 ;;=this field should be either a or b, depending on which parameter this
 ;;^DD(17.60012,.02,21,4,0)
 ;;=should be.
 ;;^DD(17.60012,.02,"DT")
 ;;=3190117
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",0)
 ;;=17.6001^B^Uniqueness Index for Key 'A' of File #17.6001^MU^^R^IR^I^17.6001^^^^^LS
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",1)
 ;;=S ^%web(17.6001,"B",X(1),X(2),X(3),DA)=""
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",2)
 ;;=K ^%web(17.6001,"B",X(1),X(2),X(3),DA)
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",2.5)
 ;;=K ^%web(17.6001,"B")
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,0)
 ;;=^.114IA^3^3
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,1,0)
 ;;=1^F^17.6001^.01^^1^F
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,1,3)
 ;;=
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,2,0)
 ;;=2^F^17.6001^1^^2^F
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,2,3)
 ;;=
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,3,0)
 ;;=3^F^17.6001^2^^3^F
 ;;^UTILITY("KX",$J,"IX",17.6001,17.6001,"B",11.1,3,3)
 ;;=

%webINI3
%webINI3 ; ; 22-JAN-2019
 ;;1.0;MUMPS WEB SERVER;;JAN 22, 2019
 ;
 ;
 K ^UTILITY("DIFROM",$J) S DIC(0)="LX",(DIC,DLAYGO)=3.6,N="BUL" D ADD:$D(^XMB(3.6,0))
 S X=0 F R=0:0 S X=$O(^UTILITY("DIFROM",$J,N,X)) Q:X=""  W !,"'",X,"' BULLETIN FILED -- Remember to add mail groups for new bulletins."
 I $D(^DIC(9.4,0))#2,^(0)?1"PACK".E S N="PKG",(DIC,DLAYGO)=9.4 D ADD
 G NP:'$D(DA) S %=+$O(^DIC(9.4,DA,22,"B",DIFROM,0)) I $D(^DIC(9.4,DA,22,%,0)) S $P(^(0),U,3)=DT
 I $D(^DIC(9.4,DA,0))#2 S %=$P(^(0),U,4) I %]"" S %=$O(^DIC(9.2,"B",%,0)) S:%]"" $P(^DIC(9.4,DA,0),U,4)=%
OR I $D(^ORD(100.99))&$O(^UTILITY(U,$J,"OR","")) D EN^%webINI4
NP K DIC,^UTILITY("DIFROM",$J) S DIC(0)="LX" I $D(^DIC(19,0))#2,^(0)?1"OPTION".E S (DIC,DLAYGO)=19,N="OPT" D ADD,OP
 I $D(^DIC(19.1,0))#2,($P(^(0),U)?1"SECUR".E)!($P(^(0),U)="KEY") S (DIC,DLAYGO)=19.1,N="KEY" D ADD K ^UTILITY("DIFROM",$J)
 I $D(^DIC(9.8,0))#2,^(0)?1"ROUTINE^".E S (DIC,DLAYGO)=9.8,N="RTN" D ADD
 S DIC=.5,DLAYGO=0,N="FUN" D ADD
 I $P($G(^DIC(8994,0)),U)="REMOTE PROCEDURE" S (DIC,DLAYGO)=8994,N="REM" D ADD
 S DIC("S")="I $P(^(0),U,4)=DIFL" F N="DIPT","DIBT","DIE" S DIC=U_N_"(" D ADD
 K DIC("S") S N="DIST(.404,",DIC=U_N,DLAYGO=.404 D ADD
 S DIC("S")="I $P(^(0),U,8)=DIFL",N="DIST(.403,",DIC=U_N,DLAYGO=.403 D ADD
 K ^UTILITY(U,$J),DIC,DLAYGO F DIFR="DIE","DIPT" D DIEZ
 K ^UTILITY("DIFROM",$J) Q
DIEZ I ^DD("VERSION")>17.4,'$D(DISYS) D OS^DII
 E  S DISYS=^DD("OS")
 Q:'$D(^DD("OS",DISYS,"ZS"))
 S DIFR1=""
DZ1 S DIFR1=$O(^UTILITY("DIFROM",$J,DIFR,DIFR1)) Q:DIFR1=""
 F DIFR2=0:0 S DIFR2=$O(^UTILITY("DIFROM",$J,DIFR,DIFR1,DIFR2)) Q:'DIFR2  S Y=DIFR2 I $D(@(U_DIFR_"(Y,""ROU"")")) K ^("ROU") I $D(^("ROUOLD")) S X=^("ROUOLD"),DMAX=^DD("ROU") D:X]"" @("EN^DI"_$E(DIFR,3)_"Z")
 G DZ1
 ;
OP S R=$O(^UTILITY("DIFROM",$J,N,R)) I R="" K ^UTILITY("DIFROM",$J) G Q
 W !,"'"_R_"' Option Filed" S DA=+^UTILITY("DIFROM",$J,N,R) G:$P(^(R),U,2,3)="XUCORE^"!($P(^(R),U,2,3)="XUCOMMAND^") OP
 I $D(^DIC(19,DA,220)) S %=$P(^(220),U) S:%]"" %=$O(^XMB(3.6,"B",%,0)) S $P(^DIC(19,DA,220),U)=%,%=$P(^(220),U,3) S:%]"" %=$O(^XMB(3.8,"B",%,0)) S $P(^DIC(19,DA,220),U,3)=%
 S %=$P(^DIC(19,DA,0),U,12) S:%]"" %=$O(^DIC(9.4,"B",%,0))
 S $P(^DIC(19,DA,0),U,12)=%,%=$P(^(0),U,7),(DZ,DIX)=0
 D:$D(^DIC(19,DA,10,"B")) KAD(DA) S:%]"" %=$O(^DIC(9.2,"B",%,0)) S $P(^DIC(19,DA,0),U,7)=%,%=$P(^(0),U,4),%="MOQXL"[% K ^(10,"B"),^("C")
 F X=0:0 S X=$O(^DIC(19,DA,10,X)) Q:'X  S I=$S($D(^(X,0)):^(0),1:0),Y=$S($D(^(U)):^(U),1:"") K ^DIC(19,DA,10,X) I Y]"",% S D=$O(^DIC(19,"B",Y,0)) I D S ^DIC(19,DA,10,X,0)=D_U_$P(I,U,2,9),DZ=DZ+1,DIX=X
 S:% ^DIC(19,DA,10,0)="^19.01PI^"_DIX_U_DZ D IX1^DIK G OP
 ;
ADD F R=0:0 S R=$O(^UTILITY(U,$J,N,R)) Q:R=""  S X=$P(^(R,0),U),DIFL=$S(N="DIST(.403,":$P(^(0),U,8),N="DIST(.404,":$P(^(0),U,2),1:$P(^(0),U,4)) W "." K DA D ^DIC I Y>0,'$D(DIFQ($E(N,1,3)))!$P(Y,U,3) S Y=Y_U D A
Q Q
A I N="BUL" K % S %(0)=$G(@(DIC_"+Y,2,0)")) F %=0:0 S %=$O(@(DIC_"+Y,2,%)")) Q:'%  S %(%)=$G(^(%,0))
 K:N'="KEY"&(N'="OPT") @(DIC_"+Y)") S ^UTILITY("DIFROM",$J,N,X)=Y S:$E(N,1,2)="DI" ^(X,+Y)="" S:N="PKG" DIFROM(0)=+Y Q:$P(Y,U,2,3)="XUCORE^"!($P(Y,U,2,3)="XUCOMMAND^")
 I N="BUL",%(0)]"" S @(DIC_"+Y,2,0)")=%(0) F %=0:0 S %=$O(%(%)) Q:'%  S @(DIC_"+Y,2,%,0)")=%(%)
 I $E(N,1,2)="DI",('DIFL)!('$D(^DD(+DIFL))) D
 .W !,"**WARNING--"_$S(N="DIE":"INPUT",N="DIPT":"PRINT",N="DIBT":"SORT",1:"FORM or BLOCK")_$S(N'["DIST":" template ",1:" ")_$P(Y,U,2)_" has been installed,",!,"but associated file "_DIFL_" is not on your system!"
 .Q
 I N="OPT" S:$P(^DIC(19,+Y,0),U,6)]"" DIOPT=$P(^(0),U,6) I $O(^UTILITY(U,$J,N,R,1,0)) K ^DIC(19,+Y,1)
 I N="DIST(.403," D BLK
 S %X="^UTILITY(U,$J,N,R,",%Y=DIC_"+Y,",DA=+Y,DIK=DIC D %XY^%RCR
 D IX1^DIK:N'="OPT" I N="OPT",$D(DIOPT) S:$P(^DIC(19,DA,0),U,6)="" $P(^(0),U,6)=DIOPT K DIOPT
 I N="DIST(.403," D
 .N DIFRVAL S DIFRVAL=$$VAL^DIFROMSS(.403,DA)
 .I DIFRVAL W !,"Compiling form: ",$P(^DIST(.403,DA,0),U) D EN^DDSZ(DA) Q
 .W !,"ERROR: Form: ",$P(^DIST(.403,DA,0),U)," cannot be compiled"
 .Q
 Q
BLK F J=0:0 S J=$O(^UTILITY(U,$J,N,R,40,J)) Q:'J  I $D(^(J,0)) S %=$P(^(0),U,2) S:%]"" %=$O(^DIST(.404,"B",%,0)) S:% $P(^UTILITY(U,$J,N,R,40,J,0),U,2)=% D B1
 K A0,A1,A2,J,L Q
B1 F L=0:0 S L=$O(^UTILITY(U,$J,N,R,40,J,40,L)) Q:'L  S A0=$G(^(L,0)),%=$P(A0,U) I %]"" S %=$O(^DIST(.404,"B",%,0)) I % S $P(A0,U)=%,^UTILITY(U,$J,N,R,40,J,"BLK",%,0)=A0 D
 .N X S X=0
 .F  S X=$O(^UTILITY(U,$J,N,R,40,J,40,L,X)) Q:X=""  S ^UTILITY(U,$J,N,R,40,J,"BLK",%,X)=^(X)
 .Q
 S A0=$G(^UTILITY(U,$J,N,R,40,J,40,0)) Q:A0=""  K ^UTILITY(U,$J,N,R,40,J,40) S (A1,A2)=0
 F L=0:0 S L=$O(^UTILITY(U,$J,N,R,40,J,"BLK",L)) Q:'L  S ^UTILITY(U,$J,N,R,40,J,40,L,0)=^(L,0),A1=L,A2=A2+1 D
 .N X S X=0
 .F  S X=$O(^UTILITY(U,$J,N,R,40,J,"BLK",L,X)) Q:X=""  S ^UTILITY(U,$J,N,R,40,J,40,L,X)=^(X)
 .Q
 S $P(A0,U,3,4)=A1_U_A2,^UTILITY(U,$J,N,R,40,J,40,0)=A0 K ^UTILITY(U,$J,N,R,40,J,"BLK")
 Q
KAD(D0) N D1,X
 S X=0 F  S X=$O(^DIC(19,D0,10,"B",X)) Q:X'>0  S D1=0 F  S D1=$O(^DIC(19,D0,10,"B",X,D1)) Q:D1'>0  K ^DIC(19,"AD",X,D0,D1)
 Q

%webINI4
%webINI4 ; ; 22-JAN-2019
 ;;1.0;MUMPS WEB SERVER;;JAN 22, 2019
 ;
 ;
EN S DA(1)=1,DIK="^ORD(100.99,1,5," I $D(^ORD(100.99,1,5,DA)) D ^DIK
 S %X="^UTILITY(U,$J,""OR"","_$O(^UTILITY(U,$J,"OR",""))_",",%Y=DIK_DA_","
 S:'$D(^ORD(100.99,1,5,0)) ^(0)="^100.995P^^" S $P(^(0),U,3,4)=DA_U_($P(^(0),U,4)+1)
 D %XY^%RCR S $P(^ORD(100.99,1,5,DA,0),U)=DA,%=$P(^(0),U,4)
 I %]"" S %=$O(^ORD(100.98,"B",%,0)) I %>0 S $P(^ORD(100.99,1,5,DA,0),U,4)=%
 D OR
 S DA(1)=1 D IX1^DIK
 Q
OR S (N,I)=0,X=""
 F  S N=$O(^ORD(100.99,1,5,DA,1,N)) Q:'N  S X=$P(^(N,0),U) I X]"" S %=$O(^ORD(101,"B",X,0)) D:'% ADDP S:% ^ORD(100.99,1,5,DA,1,N,0)=% S X=N,I=I+1,(R,J)=0,Y="" D OR1
 S:I $P(^ORD(100.99,1,5,DA,1,0),U,3,4)=X_U_I S (N,I)=0,X=""
 F  S N=$O(^ORD(100.99,1,5,DA,5,N)) Q:'N  S X=$P(^(N,0),U,3) I X]"" S %=$O(^ORD(101,"B",X,0)) D:'% ADDP S:% $P(^ORD(100.99,1,5,DA,5,N,0),U,3)=% S X=N,I=I+1
 S:I $P(^ORD(100.99,1,5,DA,5,0),U,3,4)=X_U_I K N,R,X,Y,I,J
 Q
OR1 N X F  S R=$O(^ORD(100.99,1,5,DA,1,N,1,R)) Q:'R  S X=$P(^(R,0),U) I X]"" S %=$O(^ORD(101,"B",X,0)) D:'% ADDP S:% ^ORD(100.99,1,5,DA,1,N,1,R,0)=% S Y=R,J=J+1
 S:J $P(^ORD(100.99,1,5,DA,1,N,1,0),U,3,4)=Y_U_J
 Q
ADDP N I,J,N,R,DA,DLAYGO,DO S %=""
 S DIC="^ORD(101,",DIC(0)="LX",DLAYGO=101 D FILE^DICN K DIC Q:Y=-1  S %=+Y Q

%webI002
%webI002 ; ; 22-JAN-2019
 ;;1.0;MUMPS WEB SERVER;;JAN 22, 2019
 F I=1:2 S X=$T(Q+I) Q:X=""  S Y=$E($T(Q+I+1),4,999),X=$E(X,4,999) S:$A(Y)=126 I=I+1,Y=$E(Y,2,999)_$E($T(Q+I+1),5,999) S:$A(Y)=61 Y=$E(Y,2,999) X NO E  S @X=Y
Q Q
 ;;^UTILITY(U,$J,"SBF",17.6001,17.6001)
 ;;=
 ;;^UTILITY(U,$J,"SBF",17.6001,17.60012)
 ;;=

%webapi
%webapi ; OSE/SMH - Infrastructure web services hooks;2019-11-14  11:35 AM
 ;
R(RESULT,ARGS) ; [Public] GET /r/{routine} Mumps Routine
 S RESULT("mime")="text/plain; charset=utf-8"
 S RESULT=$NA(^TMP($J))
 K @RESULT
 N RTN S RTN=$G(ARGS("routine"))
 N OFF,I
 I RTN]""&($T(^@RTN)]"") F I=1:1 S OFF="+"_I,LN0=OFF_"^"_RTN,LN=$T(@LN0) Q:LN=""  S @RESULT@(I)=LN_$C(13,10)
 E  K RESULT("mime") D setError^%webutils(404,"Routine not found")
 QUIT
 ;
PR(ARGS,BODY,RESULT) ; [Public] PUT /r/{routine} Mumps Routine
 S HTTPRSP("mime")="text/plain; charset=utf-8" ; Character set of the return URL
 N PARSED ; Parsed array which stores each line on a separate node.
 D PARSE10^%webutils(.BODY,.PARSED) ; Parser
 N DIE,XCN S DIE="PARSED(",XCN=0 D SAVE(ARGS("routine"))
 Q "/r/"_ARGS("routine")
 ;
SAVE(RN) ; [Private] Save a routine
 Q:$E(RN,1,4)'="KBAN"  ; Just for this server, don't do this.
 N %,%F,%I,%N,SP,$ETRAP
 S $ETRAP="S $ECODE="""" Q"
 S %I=$I,SP=" ",%F=$$RTNDIR^%ZOSV()_$TR(RN,"%","_")_".m"
 O %F:(newversion:noreadonly:blocksize=2048:recordsize=2044) U %F
 F  S XCN=$O(@(DIE_XCN_")")) Q:XCN'>0  S %=@(DIE_XCN_")") Q:$E(%,1)="$"  I $E(%)'=";" W %,!
 C %F ;S %N=$$NULL
 ZLINK RN
 ;C %N
 U %I
 Q
 ;
ERR(RESULT,ARGS) ; GET /error Force M Error
 I $G(ARGS("foo"))="crash2" S %webcrash2=1 ; crash the error trap
 D ERR1
 QUIT
ERR1 ;
 N X S X=1/0
 ;
bigoutput(result,args) ; GET /bigoutput - Used by Unit Tests to ensure large output is handled appropriately
 n a,b,c
 s $p(a,"a",2**10)="a"
 n i for i=1:1:32 s result(i)=a
 s result(32)=$e(result(32),1,$l(result(32))-1)
 s b=$c(13,10)
 s result(33)=b
 s result("mime")="text/plain; charset=utf-8" ; type of data to send browser
 quit
 ;
ping(RESULT,ARGS) ; writes out a ping response
 S RESULT="{""status"":"""_$J_" running""}"
 Q
xml(RESULT,ARGS) ; text XML
 S HTTPRSP("mime")="text/xml"
 S RESULT=$NA(^TMP($J))
 S ^TMP($J,1)="<?xml version=""1.0"" encoding=""UTF-8""?>"
 S ^TMP($J,2)="<note>"
 S ^TMP($J,3)="<to>Tovaniannnn</to>"
 S ^TMP($J,4)="<from>Jani</from>"
 S ^TMP($J,5)="<heading>Reminders</heading>"
 S ^TMP($J,6)="<body>Don't forget me this weekend!</body>"
 S ^TMP($J,7)="</note>"
 QUIT
 ;
customerr(r,a) ; custom error
 n errarr
 s errarr("resourceType")="OperationOutcome"
 s errarr("issue",1,"severity")="error"
 s errarr("issue",1,"code")="processing"
 s errarr("issue",1,"diagnostics")="Test message"
 d customError^%webutils(400,.errarr)
 quit
 ;
empty(r,a) ; Empty. Used For Unit Tests
 s r=""
 QUIT
 ;
FV(RESULTS,ARGS) ; Get fileman field value, handles fileman/file/iens/field
 I $$UNKARGS^%webutils(.ARGS,"file,iens,field,screen,match") Q  ; Is any of these not passed?
 S RESULTS("mime")="text/plain; charset=utf-8" ; type of data to send browser
 N FILE S FILE=$G(ARGS("file")) ; se
 N IENS S IENS=$G(ARGS("iens")) ; se
 N FIELD S FIELD=$G(ARGS("field")) ; se
 I IENS?1A.AN D LISTER(.RESULTS,.ARGS) QUIT
 S RESULTS=$$GET1^DIQ(FILE,IENS,FIELD,,$NA(^TMP($J))) ; double trouble.
 I $D(^TMP("DIERR",$J)) D SETERROR^%webutils(404,"File or field not found") QUIT
 ; if results is a regular field, that's the value we will get.
 ; if results is a WP field, RESULTS becomes the global ^TMP($J).
 I $D(^TMP($J)) D ADDCRLF^%webutils(.RESULTS) ; crlf the result
 ;ZSHOW "D":^KBANDEV
 QUIT
 ;
LISTER(RESULTS,ARGS) ; FV divergence in case an index is requested.
 K RESULTS("mime")
 N FILE S FILE=$G(ARGS("file"))
 N INDEX S INDEX=$G(ARGS("iens"))
 N FROM S FROM=$G(ARGS("field"))
 ; I $L(FROM) D 
 ; . I +FROM'=FROM S FROM=$E(FROM,1,$L(FROM)-1)_"              " ; backtrack in index alpha style
 ; . E  S FROM=FROM-1   ; backtrack numeric style
 ;
 N SCREEN S SCREEN=$G(ARGS("screen"))
 I $L(SCREEN) D
 . N Q S Q=""""
 . N FLD,VAL
 . S FLD=$P(SCREEN,":")
 . S VAL=$P(SCREEN,":",2)
 . I VAL'=+VAL S VAL=Q_VAL_Q ; Quote literal values
 . N FLDNUM S FLDNUM=$O(^DD(FILE,"B",FLD,""))
 . Q:'FLDNUM
 . N GL S GL=$P(^DD(FILE,FLDNUM,0),U,4)
 . N GLN S GLN=$P(GL,";")
 . I GLN'=+GLN S GLN=Q_GLN_Q ; Quote literal nodes
 . N GLP S GLP=$P(GL,";",2)
 . I $E(GLP)="E" D
 . . N START S START=$P(GLP,","),START=$E(GLP,2,99)
 . . N END S END=$P(GLP,",",2)
 . . S SCREEN="I $E(^("_GLN_"),"_START_","_END_")="_VAL
 . E  D
 . . S SCREEN="I $P(^("_GLN_"),U,"_GLP_")="_VAL
 ;
 N FLAGS S FLAGS="QP" ; Default flag
 ; 
 ; TODO: if index is not compound, don't apply matching below; send X flag to finder instead.
 ; I $G(ARGS("match"))="exact" S FLAGS=FLAGS_"X"
 N %WRES,%WERR
 ; %WRES("DILIST",0)="200^200^1^"
 ; %WRES("DILIST",0,"MAP")="IEN^IX(1)^.01^FID(.12)^FID(.13)^FID(.14)"
 ; %WRES("DILIST",1,0)="8870^CA - CALCIUM^1895^SNOMEDCT^SY^5540006"
 ; %WRES("DILIST",2,0)="60527^CA - CHOLIC ACID^20969^SNOMEDCT^SY^17147002"
 ; %WRES("DILIST",3,0)="606334^CA 1000/MAGNESIUM 400/ZINC 15M^810433^VANDF^AB^40252
 I FROM="" D
 . D LIST^DIC(FILE,,"IX;FID",FLAGS,200,,,INDEX,SCREEN,"",$NA(%WRES),$NA(%WERR))
 E  D FIND^DIC(FILE,,"IX;FID",FLAGS,FROM,200,INDEX,SCREEN,"",$NA(%WRES),$NA(%WERR))
 ;
 ; 
 ; Filter only for exact matches if requested. 
 ; Get IX(1) entries and make sure they are the same as the original values.
 I $G(ARGS("match"))="exact" D
 . ; I looper to set IX(1) piece location
 . N I F I=1:1:$L(%WRES("DILIST",0,"MAP"),U) Q:$P(%WRES("DILIST",0,"MAP"),U,I)="IX(1)"
 . N IX1P S IX1P=I ; IX(1) piece location
 . N I S I=0 F  S I=$O(%WRES("DILIST",I)) Q:'I  D  ; Remove IX(1)'s that don't match
 . . I $P(%WRES("DILIST",I,0),U,IX1P)'=FROM K %WRES("DILIST",I,0)
 ;
 ;
 ; K ^KBANRPC ZSHOW "*":^KBANRPC
 ;
 ;
 I $D(DIERR) D SETERROR^%webutils("500","Lister error") Q
 N MAP S MAP=%WRES("DILIST",0,"MAP")
 S MAP=$$REMAP(MAP,FILE)
 N %WRES2
 N I S I=0
 F  S I=$O(%WRES("DILIST",I)) Q:'I  D
 . N IEN
 . S NODE=%WRES("DILIST",I,0)
 . N P F P=1:1:$L(MAP,U) I $P(MAP,U,P)["IEN" S IEN=$P(NODE,U,P)
 . N P F P=1:1:$L(MAP,U) S %WRES2(IEN,$P(MAP,U,P))=$P(NODE,U,P)
 . K %WRES("DILIST",I,0)
 K %WRES("DILIST",0)
 N %WJSON,%WERR
 D encode^%webjson($NA(%WRES2),$NA(%WJSON),$NA(%WERR))
 I $D(%WERR) D SETERROR^%webutils("500","Error in JSON conversion") Q
 M RESULTS=%WJSON
 QUIT
 ;
REMAP(MAP,FILE) ; Private $$ - Remap the map from the lister
 N NEWMAP
 N I F I=1:1:$L(MAP,U) D
 . N P S P=$P(MAP,U,I)
 . I P["IX(" S P="INDEX VALUE "_+$P(P,"IX(",2)
 . I $E(P,1,3)=".01" S P="#"_P_" "_$$GET1^DID(FILE,.01,"","LABEL")
 . I P["FID(" N FLD S FLD=+$P(P,"FID(",2),P="#"_FLD_" "_$$GET1^DID(FILE,FLD,"","LABEL")
 . I P="IEN" S P="#.001 IEN"
 . S $P(NEWMAP,U,I)=P
 Q NEWMAP
 ;
LISTERT 
 N ARGS S ARGS("file")=176.001,ARGS("iens")="STR",ARGS("field")="CA"
 D LISTER(,.ARGS)
 N ARGS S ARGS("file")=176.005,ARGS("iens")="B",ARGS("field")="87795"
 D LISTER(,.ARGS)
 QUIT
 ;
F(RESULT,ARGS) ; handles fileman/{file}/{iens}
 I $$UNKARGS^%webutils(.ARGS,"file,iens") Q  ; Is any of these not passed?
 N FILE S FILE=$G(ARGS("file")) ; se
 N IENS S IENS=$G(ARGS("iens")) ; se
 N %WRTN,%WERR
 N DIERR
 D GETS^DIQ(FILE,IENS,"*","RN",$NA(%WRTN),$NA(%WERR))
 I $D(DIERR) D SETERROR^%webutils("500","Error in GETS^DIQ Selection") Q
 N %WERR
 D encode^%webjson($NA(%WRTN(FILE,IENS_",")),$NA(RESULT),$NA(%WERR))
 ; debug
 ;K ^KBANRPC 
 ;ZSHOW "V":^KBANRPC
 ; debug
 I $D(%WERR) D SETERROR^%webutils("500","Error in JSON conversion") Q
 QUIT
 ;
POSTTEST(ARGS,BODY,RESULT) ; POST XML to a WP field in Fileman; handles /xmlpost
 N IEN S IEN=$O(^%W(6.6002,""),-1)+1
 N %WFDA S %WFDA(6.6002,"?+1,",.01)=IEN D UPDATE^DIE("",$NA(%WFDA))
 S RESULT="/fileman/6.6002/"_IEN_"/"_1 ; Stored URL
 N PARSED ; Parsed array which stores each line on a separate node.
 D PARSE10^%webutils(.BODY,.PARSED) ; Parser
 D WP^DIE(6.6002,IEN_",",1,"K",$NA(PARSED)) ; File WP field; lock record in process.
 ; ZSHOW "V":^KBANPARSED
 S RESULT("mime")="text/plain; charset=utf-8" ; Character set of the return URL
 Q RESULT
 ;
RPC(ARGS,BODY,RESULT) ; POST to execute Remote Procedure Calls; handles POST rpc/{rpc}
 ; Very simple... no security checking
 N RP S RP=$G(ARGS("rpc"))
 I '$L(RP) D SETERROR^%webutils("400","Remote procedure not specified") Q ""
 ;
 N DIQUIET S DIQUIET=1 D DT^DICRW ; Set up "^" as U
 ;
 N XWB
 S XWB(2,"RPC")=RP
 N % S %=$$RPC^XWBPRS()
 I % D SETERROR^%webutils("404","Remote procedure not found") Q ""
 ;
 N PARAMS,%WERR
 I $D(BODY) D decode^%webjson($NA(BODY),$NA(PARAMS),$NA(%WERR))
 ;
 ; debug
 ;K ^KBANRPC 
 ;M ^KBANRPC=BODY,^KBANRPC=RP
 ;ZSHOW "V":^KBANRPC
 ; debug
 ;
 I $D(%WERR) D SETERROR^%webutils("400","Input parameters not correct")
 ;
 ; Loop through the PARAMS and construct an argument list
 ; TODO: Two uncommonly used types are global and reference parameter. Need to do if we want to emulate broker completely.
 N ARGLIST S ARGLIST=""  ; Argument list, starting empty
 ;
 I $D(PARAMS) F I=1:1:$O(PARAMS(""),-1) N @("A"_I)  ; New parameter variables, stored in A1,A2,A3 etc.
 D:$D(PARAMS)
 . N I F I=0:0 S I=$O(PARAMS(I)) Q:'I  D
 . . I $D(PARAMS(I))[0 D  ; Reference Parameter
 . . . M @("A"_I)=PARAMS(I) S ARGLIST=ARGLIST_".A"_I_","
 . . E  D  ; Literal Param
 . . . S @("A"_I)=PARAMS(I),ARGLIST=ARGLIST_"A"_I_","
 ;
 S ARGLIST=$E(ARGLIST,1,$L(ARGLIST)-1) ; Remove trailing comma
 ;
 N %WCALL
 N RPCRESULT
 I $L(ARGLIST) S %WCALL="D "_XWB(2,"RTAG")_"^"_XWB(2,"RNAM")_"(.RPCRESULT,"_ARGLIST_")" ; Routine call with arguments
 E  S %WCALL="D "_XWB(2,"RTAG")_"^"_XWB(2,"RNAM")_"(.RPCRESULT)" ; Routine call with no arguments
 ;
 X %WCALL ; Action!
 ;
 if ARGS("rpc")'["JSON" D ADDCRLF^%webutils(.RPCRESULT) ; Add CRLF to each line if not JSON
 ;
 M RESULT=RPCRESULT
 ;
 ;
 S RESULT("mime")="text/plain; charset=utf-8" ; Character set of the return
 Q "/rpc/"_ARGS("rpc")
 ;
rpc2(result,rpcName,start,direction,body) ; Demo entry point using parameters
 ; Call like this: curl http://SM1234:CATDOG.44@localhost:9080/rpc2/ORWU%20NEWPERS -d 'start=A&direction=1'
 if rpcName'="ORWU NEWPERS" quit
 ;
 n rpcResult
 d NEWPERS^ORWU(.rpcResult,start,direction)
 D ADDCRLF^%webutils(.rpcResult)
 m result=rpcResult
 s result("mime")="text/plain; charset=utf-8" ; Character set of the return
 Q "/rpc2/ORWU NEWPERS"
 ;
FILESYS(RESULT,ARGS) ; Handle filesystem/*
 I '$D(ARGS)&$D(PATHSEG) S ARGS("*")=PATHSEG
 N ISGTM S ISGTM=$P($SY,",")=47
 N ISCACHE S ISCACHE=$L($SY,":")=2
 N PATH
 ;
 ; Where is our home? If any home!
 I ('$G(NOGBL)),($G(^%webhome)'="") D
 . I ISGTM S $ZD=^%webhome ; GT.M
 . I ISCACHE N % S %=$ZU(168,^%webhome) ; Cache
 ;
 ; Ok, get the actual path
 I ISGTM S PATH=$ZDIRECTORY_ARGS("*") ; GT.M Only!
 I ISCACHE S PATH=$ZU(168)_ARGS("*") ; Cache Only!
 ;
 ; GT.M errors out on FNF; Cache blocks. Need timeout and else.
 N $ET S $ET="G FILESYSE"
 ;
 ; Fixed prevents Reads to terminators on SD's. CHSET makes sure we don't analyze UTF.
 I ISGTM O PATH:(REWIND:READONLY:FIXED:CHSET="M")
 ;
 ; This mess for Cache!
 N POP S POP=0
 I ISCACHE O PATH:("RU"):0  E  S POP=1  ; Cache must have a timeout; U = undefined.
 I POP G FILESYSE
 ;
 ; Prevent End of file Errors for Cache. Set DSM mode for that.
 I ISCACHE D $SYSTEM.Process.SetZEOF(1) ; Cache stuff!!
 ;
 ; Set content-cache value; defaults to one week.
 set RESULT("cache")=604800
 ;
 ; Get mime type
 ; TODO: Really really needs to be in a file
 ; This isn't complete, by any means; it just grabs the most likely types to be
 ; found on an M Web Server. A few common Microsoft types are supported, but
 ; few other vendor-specific types are. Also, there are a few Mumps-centric
 ; types added below (under the x- prefix). If it's an unrecognized file
 ; extension, it's set to text.
 new MIMELKUP
 set MIMELKUP("aif")="audio/aiff"
 set MIMELKUP("aiff")="audio/aiff"
 set MIMELKUP("au")="audio/basic"
 set MIMELKUP("avi")="video/avi"
 set MIMELKUP("css")="text/css"
 set MIMELKUP("csv")="text/csv"
 set MIMELKUP("doc")="application/msword"
 set MIMELKUP("gif")="image/gif"
 set MIMELKUP("htm")="text/html"
 set MIMELKUP("html")="text/html"
 set MIMELKUP("ico")="image/x-icon"
 set MIMELKUP("jpe")="image/jpeg"
 set MIMELKUP("jpeg")="image/jpeg"
 set MIMELKUP("jpg")="image/jpeg"
 set MIMELKUP("js")="application/javascript"
 set MIMELKUP("kid")="text/x-mumps-kid"
 set MIMELKUP("m")="text/x-mumps"
 set MIMELKUP("mov")="video/quicktime"
 set MIMELKUP("mp3")="audio/mpeg3"
 set MIMELKUP("pdf")="application/pdf"
 set MIMELKUP("png")="image/png"
 set MIMELKUP("ppt")="application/vnd.ms-powerpoint"
 set MIMELKUP("ps")="application/postscript"
 set MIMELKUP("qt")="video/quicktime"
 set MIMELKUP("svg")="image/svg+xml"
 set MIMELKUP("tex")="application/x-tex"
 set MIMELKUP("tif")="image/tiff"
 set MIMELKUP("tiff")="image/tiff"
 set MIMELKUP("txt")="text/plain"
 set MIMELKUP("log")="text/plain"
 set MIMELKUP("wav")="audio/wav"
 set MIMELKUP("xls")="application/vnd.ms-excel"
 set MIMELKUP("zip")="application/zip"
 new EXT set EXT=$PIECE(PATH,".",$LENGTH(PATH,"."))
 if $DATA(MIMELKUP(EXT)) set RESULT("mime")=MIMELKUP(EXT)
 else  set RESULT("mime")=MIMELKUP("txt")
 ;
 ; Read operation
 U PATH
 N C S C=1
 N X F  R X#4079:0 S RESULT(C)=X,C=C+1 Q:$ZEOF
 C PATH
 QUIT
 ;
FILESYSE ; 500
 S $EC=""
 D setError^%webutils("500",$S($P($SY,",")=47:$ZS,1:$ZE))
 QUIT
 ;
 ; Copyright 2013-2019 Sam Habiel
 ; Copyright 2018 Kenneth McLoghlen
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%weburl
%weburl ;YottaDB/CJE -- URL Matching routine;2019-11-14  11:14 AM
 ;
 ; This routine is used to map URLs to entry points under
 ; the URLMAP entry point.
 ;
URLMAP ;
 ;;GET ping ping^%webapi
 ;;GET /test/xml xml^%webapi
 ;;GET /test/empty empty^%webapi
 ;;GET /test/customerror customerr^%webapi
 ;;zzzzz
 ;
 ; Copyright 2019 Christopher Edwards
 ; Copyright 2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%webjson
%webjson ;SLC/KCM -- Decode/Encode JSON;2019-07-16  2:17 PM
 ;
 ; Note:  Since the routines use closed array references, VVROOT and VVERR
 ;        are used to reduce risk of naming conflicts on the closed array.
 ;
decode(VVJSON,VVROOT,VVERR) G DIRECT^%webjsonDecode
DECODE(VVJSON,VVROOT,VVERR)  ; Set JSON object into closed array ref VVROOT
 ; Examples: D DECODE^VPRJSON("MYJSON","LOCALVAR","LOCALERR")
 ;           D DECODE^VPRJSON("^MYJSON(1)","^GLO(99)","^TMP($J)")
 ;
 ; VVJSON: string/array containing serialized JSON object
 ; VVROOT: closed array reference for M representation of object
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 ;   VVIDX: points to next character in JSON string to process
 ; VVSTACK: manages stack of subscripts
 ;  VVPROP: true if next string is property name, otherwise treat as value
 ;
 G DIRECT^%webjsonDecode
 ;
encode(VVROOT,VVJSON,VVERR) G DIRECT^%webjsonEncode
ENCODE(VVROOT,VVJSON,VVERR) ; VVROOT (M structure) --> VVJSON (array of strings)
 ; Examples:  D ENCODE^VPRJSON("^GLO(99,2)","^TMP($J)")
 ;            D ENCODE^VPRJSON("LOCALVAR","MYJSON","LOCALERR")
 ;
 ; VVROOT: closed array reference for M representation of object
 ; VVJSON: destination variable for the string array formatted as JSON
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 G DIRECT^%webjsonEncode
 ;
 ;
esc(x) Q $$ESC^%webjsonEncode(X)
ESC(X) ; Escape string for JSON
 Q $$ESC^%webjsonEncode(X)
 ;
ues(x) Q $$UES^%webjsonDecode(X)
UES(X) ; Unescape JSON string
 Q $$UES^%webjsonDecode(X)
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 ; switch (ID) -- XERRX ends statement
 N ERRMSG
 ;
 ; Decode Error Messages
 ;
 I ID="STL{" S ERRMSG="Stack too large for new object." G XERRX
 I ID="SUF}" S ERRMSG="Stack Underflow - extra } found" G XERRX
 I ID="STL[" S ERRMSG="Stack too large for new array." G XERRX
 I ID="SUF]" S ERRMSG="Stack Underflow - extra ] found." G XERRX
 I ID="OBM" S ERRMSG="Array mismatch - expected ] got }." G XERRX
 I ID="ARM" S ERRMSG="Object mismatch - expected } got ]." G XERRX
 I ID="MPN" S ERRMSG="Missing property name." G XERRX
 I ID="EXT" S ERRMSG="Expected true, got "_VAL G XERRX
 I ID="EXF" S ERRMSG="Expected false, got "_VAL G XERRX
 I ID="EXN" S ERRMSG="Expected null, got "_VAL G XERRX
 I ID="TKN" S ERRMSG="Unable to identify type of token, value was "_VAL G XERRX
 I ID="SCT" S ERRMSG="Stack mismatch - exit stack level was  "_VAL G XERRX
 I ID="EIQ" S ERRMSG="Close quote not found before end of input." G XERRX
 I ID="EIU" S ERRMSG="Unexpected end of input while unescaping." G XERRX
 I ID="RSB" S ERRMSG="Reverse search for \ past beginning of input." G XERRX
 I ID="ORN" S ERRMSG="Overrun while scanning name." G XERRX
 I ID="OR#" S ERRMSG="Overrun while scanning number." G XERRX
 I ID="ORB" S ERRMSG="Overrun while scanning boolean." G XERRX
 I ID="ESC" S ERRMSG="Escaped character not recognized"_VAL G XERRX
 I ID="TRL" S ERRMSG="Trailing characters in JSON object: "_VAL G XERRX
 ;
 ; Encode Error Messages
 ;
 I ID="SOB" S ERRMSG="Unable to serialize node as object, value was "_VAL G XERRX
 I ID="SAR" S ERRMSG="Unable to serialize node as array, value was "_VAL G XERRX
 S ERRMSG="Unspecified error "_ID_" "_$G(VAL)
XERRX ; end switch
 S @VVERR@(0)=$G(@VVERR@(0))+1
 S @VVERR@(@VVERR@(0))=ERRMSG
 S VVERRORS=VVERRORS+1
 Q
 ;
 ; Most of this code is public domain. New lower case entry points
 ; Copyright 2013-2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%webhome
%webhome ; VEN/SMH - Home page processor;Feb 07, 2019@10:49
 ;;
 ; Copyright 2013-2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.
 ;
en(RESULT) ; PEP
 S RESULT("mime")="text/html; charset=utf-8"
 N CRLF S CRLF=$C(13,10)
 N ARGS S ARGS("*")="index.html"
 ; Retrieve index.html from filesystem before returning default page
 D FILESYS^%webapi(.RESULT,.ARGS)
 I ('$G(NOGBL)),$D(^TMP("HTTPERR",$J)) K ^TMP("HTTPERR",$J),HTTPERR,RESULT
 ; If we found an index.html don't return the default
 I $D(RESULT) QUIT
 ; If we are in no global mode quit as well as the below loop won't tell us anything
 I $G(NOGBL) S RESULT(1)="NO INDEX FOUND!" QUIT
 ; return default index.html
 S RESULT("mime")="text/html; charset=utf-8"
 N I F I=1:1 S RESULT(I)=$P($TEXT(HTML+I),";;",2,99) Q:RESULT(I)=""  D
 . I RESULT(I)["<%TABLEDATA%>" D
 .. N IEN S IEN=0 F J=I:.0001 S IEN=$O(^%web(17.6001,IEN)) Q:'IEN  D
 ... S RESULT(J)="<tr>",J=J+.0001
 ... S RESULT(J)="<td>"_^%web(17.6001,IEN,0)_"</td>",J=J+.0001
 ... S RESULT(J)="<td>"_^%web(17.6001,IEN,1)_"</td>",J=J+.0001
 ... ;
 ... N EP S EP=^%web(17.6001,IEN,2) N RTN S RTN=$P(EP,"^",2),RTN=$$URLENC^%webutils(RTN)
 ... S RESULT(J)="<td><a href=""r/"_RTN_""">"_EP_"</td>",J=J+.0001
 ... ;
 ... N AUTH S AUTH=$P($G(^%web(17.6001,IEN,"AUTH")),"^",1),AUTH=$S(AUTH:"YES",1:"NO")
 ... S RESULT(J)="<td>"_AUTH_"</td>",J=J+.0001
 ... ;
 ... N KEY S KEY=$P($G(^%web(17.6001,IEN,"AUTH")),"^",2) I KEY S KEY=$P($G(^DIC(19.1,KEY,0)),"^")
 ... S RESULT(J)="<td>"_KEY_"</td>",J=J+.0001
 ... ;
 ... N RKEY S RKEY=$P($G(^%web(17.6001,IEN,"AUTH")),"^",3) I RKEY S RKEY=$P($G(^DIC(19.1,RKEY,0)),"^")
 ... S RESULT(J)="<td>"_RKEY_"</td>",J=J+.0001
 ... ;
 ... N OPT S OPT=$P($G(^%web(17.6001,IEN,"AUTH")),"^",4) I OPT S OPT=$P($G(^DIC(19,OPT,0)),"^")
 ... S RESULT(J)="<td>"_OPT_"</td>",J=J+.0001
 ... ;
 ... S RESULT(J)="</tr>"
 . I RESULT(I)="<%FOOTER%>" D
 .. S RESULT(I)="$JOB="_$J_" | $SYSTEM="_$SYSTEM_" | ^DD(""SITE"")="_$G(^DD("SITE"))
 .. S RESULT(I)=RESULT(I)_" | ^DD(""SITE"",1)="_$G(^DD("SITE",1))
 . S RESULT(I)=RESULT(I)_CRLF
 KILL RESULT(I) ; Kill last one which is empty.
 QUIT
 ;
HTML ; HTML to Write out
 ;;<!doctype html>
 ;;<html>
 ;;<head>
 ;;<title>MUMPS Restful Web-Services Portal</title>
 ;;<style>
 ;; body {
 ;;     margin: 0 0 0 0;
 ;;     font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
 ;;     font-size: 14px;
 ;;     line-height: 1.428571429;
 ;;     background-color: rgb(245, 217, 181)
 ;; }
 ;; header {
 ;;     background-color: rgb(92, 81, 37);
 ;;     box-sizing: border-box;
 ;;     color: rgb(253, 252, 245);
 ;;     text-align: center;
 ;;     vertical-align: middle;
 ;;     padding-top: 1.2em;
 ;;     padding-bottom: 0.5em;
 ;;     position: fixed;
 ;;     top: 0;
 ;;     right: 0;
 ;;     left: 0;
 ;;     }
 ;; header > span {
 ;;     font-size: 3em;
 ;;     line-height: 1em;
 ;; }
 ;; footer {
 ;;     background-color: black;
 ;;     box-sizing: border-box;
 ;;     color: white;
 ;;     #position: fixed;
 ;;     #bottom: 0;
 ;;     width: 100%;
 ;;     text-align: center;
 ;;     }
 ;; main {
 ;;     box-sizing: border-box;
 ;;     display: block;
 ;;     font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
 ;;     padding-bottom: 140px;
 ;;     padding-left: 15px;
 ;;     padding-right: 15px;
 ;;     padding-top: 140px;
 ;;     text-align: left;
 ;;     text-shadow: rgba(0, 0, 0, 0.14902) 0px 1px 0px;
 ;; }
 ;; table, td, tr, th {
 ;;     border: 1px solid black;
 ;;     border-collapse:collapse;
 ;;     padding: 15px;
 ;; }
 ;;</style>
 ;;</head>
 ;;<body>
 ;;<header>
 ;; <span>MUMPS Restful Web-Services Portal</span>
 ;;</header>
 ;;<main>
 ;;<p>
 ;; Welcome to the MUMPS Advanced Shell Web Services.
 ;;</p>
 ;;<p>
 ;; Here is a list of web services configured on this server.
 ;; <table>
 ;;  <tr>
 ;;   <th>HTTP VERB</th>
 ;;   <th>URI</th>
 ;;   <th>Execution Endpoint</th>
 ;;   <th>Authentication Required?</th>
 ;;   <th>Security Key</th>
 ;;   <th>Reverse Key</th>
 ;;   <th>Access to Option</th> 
 ;;   <th>Example Call</th>
 ;;   <th>Description</th>
 ;;  </tr>
 ;;    <%TABLEDATA%>
 ;; </table>
 ;;</p>
 ;;</main>
 ;;<footer>
 ;;<span>
 ;;<%FOOTER%>
 ;;</span>
 ;;</footer>
 ;;</body>
 ;;</html>

%webrsp
%webrsp ;SLC/KCM -- Handle HTTP Response;2019-11-14  11:02 AM
 ;
 ; -- prepare and send RESPONSE
 ;
RESPOND ; find entry point to handle request and call it
 ; expects HTTPREQ, HTTPRSP is used to return the response
 ;
 K:'$G(NOGBL) ^TMP($J)
 N ROUTINE,LOCATION,HTTPARGS,HTTPBODY,PARAMS,AUTHNODE
 ;
 N BODY M BODY=HTTPREQ("body") K HTTPREQ("body")
 ;
 ; Split the query string
 D QSPLIT(HTTPREQ("query"),.HTTPARGS) I $G(HTTPERR) QUIT
 ;
 ; If method is PUT/POST and we have URL encoded form data then we need to extract the form parameters
 ; and store them in HTTPARGS, this has been moved out here as this extraction needs to happen only once
 ; earlier this extraction process was getting repeated per form parameter definition leading to a performance issue
 N FORMPARAMS
 I "PUT,POST"[HTTPREQ("method")&($G(HTTPREQ("header","content-type"))["application/x-www-form-urlencoded")&($D(BODY)) D
 . N CONCATBODY S CONCATBODY=$$BODYASSTR(.BODY)
 . D QSPLIT(CONCATBODY,.FORMPARAMS)
 ;
 ; Hook for execution of any pre-hook functions that need to be executed before the server starts
 ; processing the web request
 I ('$G(NOGBL))&($G(^%webhttp(0,"preexecfunc"))'="") D
 . N r S r=^%webhttp(0,"preexecfunc")_"(.HTTPRSP,.HTTPREQ,.HTTPARGS,.FORMPARAMS)"
 . D @r K r
 I $D(HTTPRSP) D
 . I ('$G(NOGBL))&($G(^%webhttp(0,"autoserresptojson"))="Y") D
 . . K TMPHTTPRSP D encode^%webjson($NA(HTTPRSP),$NA(TMPHTTPRSP),$NA(ERR))
 . . K HTTPRSP M HTTPRSP=TMPHTTPRSP
 . . S HTTPRSP("mime")="application/json; charset=utf-8"
 Q:$D(HTTPRSP)
 I HTTPREQ("path")="/",HTTPREQ("method")="GET" D en^%webhome(.HTTPRSP) QUIT  ; Home page requested.
 I HTTPREQ("method")="OPTIONS" S HTTPRSP="OPTIONS,POST" QUIT ; Always repond to OPTIONS to give CORS header info
 ;
 ; Resolve the URL and authenticate if necessary
 D MATCH(.ROUTINE,.HTTPARGS,.PARAMS,.AUTHNODE)
 ;
 I $G(HTTPERR)    QUIT  ; Error in matching
 I $O(HTTPRSP(0)) QUIT  ; File on file system found matching path
 ;
 ; %WNULL Support for VistA - Use this device to prevent VistA from writing to you.
 N %WNULL S %WNULL=""
 I $P($SY,",")=47 S %WNULL="/dev/null"
 I $L($SY,":")=2 D
 . I $ZVERSION(1)=2 s %WNULL="//./nul"
 . I $ZVERSION(1)=3 s %WNULL="/dev/null"
 I %WNULL="" S $EC=",U-OS-NOT-SUPPORTED,"
 O %WNULL U %WNULL
 ;
 ; r will contain the routine to execute
 n r,order
 ;
 ; No parameters, do it the original way
 I '$D(PARAMS) D
 . I "PUT,POST"[HTTPREQ("method") D
 . . S order="" F  S order=$O(FORMPARAMS(order)) Q:order=""  D
 . . . S HTTPARGS(order)=FORMPARAMS(order)
 . . ; Check whether we need to pass HTTPRSP as first argument to thr routine or HTTPARGS
 . . I ('$G(NOGBL))&($G(^%webhttp(0,"firstargresponse"))="Y") D
 . . . S r=ROUTINE_"(.HTTPRSP,.HTTPARGS)"
 . . E  S r=ROUTINE_"(.HTTPARGS,.HTTPRSP)"
 . E  D
 . . I ('$G(NOGBL))&($G(^%webhttp(0,"firstargresponse"))="Y") D
 . . . S r=ROUTINE_"(.HTTPRSP,.HTTPARGS)"
 . . E  D
 . . . I ROUTINE["$$" S r=ROUTINE_"(.HTTPARGS,.HTTPRSP)"
 . . . E  S r=ROUTINE_"(.HTTPRSP,.HTTPARGS)"
 ;
 ;
 ; Parameters, do it the new way
 else  s r=ROUTINE_"(.HTTPRSP," f order=0:0 s order=$O(PARAMS(order)) quit:'order  new @("a"_order) do  quit:$get(HTTPERR)
 . ; PARAMS(0)="^17.60012S^1^1"
 . ; PARAMS(1,0)="U^rpc"
 . ;
 . ; Set arguments into variables
 . n type s type=$p(PARAMS(order,0),"^",1)
 . n name s name=$p(PARAMS(order,0),"^",2)
 . n var  s var="a"_order
 . if type="U"!(type="Q") do  ; URL component or HTTP GET Query parameter
 .. set @var=$get(HTTPARGS(name))
 .. set r=r_var_","
 . if type="H" do  ; HTTP Header
 .. set @("a"_order)=$get(HTTPREQ("header",name))
 .. set r=r_var_","
 . if type="F" do  ; application/x-www-form-urlencoded form
 .. set @var=$g(formParams(name))
 .. set r=r_var_","
 . if type="B" do  ; whole body
 .. set r=r_".BODY"_","
 . ;
 . ; replace trailing comma with close paran
 if $extract(r,$l(r))="," set $extract(r,$l(r))=")"
 ;
 N D,DA,DGVAUSER,DILOCKTM,DISYS,EXPS,IO,IOBS,IOF,IOM,IOSL,IOST,IOST,IOT,K,POP,T,TCPX,TLSCONFIG,TRACE,USERPASS,X,XPARSYS,Y,order
 I ROUTINE["$$" xecute "S LOCATION="_r
 E  d @r
 ;
 ; if setting for json serialization is enabled then perform auto json serialization for response object
 I ('$G(NOGBL))&($G(^%webhttp(0,"autoserresptojson"))="Y")&(ROUTINE["$$") D
 . ; Check whether we have http response status code or any other http headers present in the special _http key
 . N TMPHTTPR M TMPHTTPR=HTTPRSP("_http")
 . K HTTPRSP("_http")
 . K TMPHTTPRSP D encode^%webjson($NA(HTTPRSP),$NA(TMPHTTPRSP),$NA(ERR))
 . K HTTPRSP M HTTPRSP=TMPHTTPRSP
 . S HTTPRSP("mime")="application/json; charset=utf-8"
 . S order=0 F  S order=$O(TMPHTTPR(order)) Q:'order  D
 . . S HTTPRSP(order)=TMPHTTPR(order)
 ;
 if $get(LOCATION)'="" do
 . S HTTPREQ("location")=$S($D(HTTPREQ("header","host")):HTTPREQ("header","host")_LOCATION,1:LOCATION)
 . if $get(TLSCONFIG)'="" set HTTPREQ("location")="https://"_HTTPREQ("location")
 . else                   set HTTPREQ("location")="http://"_HTTPREQ("location")
 ;
 ; Back to our original device
 C %WNULL U %WTCP
 ;
 Q
 ;
QSPLIT(QPARAMS,QUERY) ; parses and decodes query fragment into array
 ; expects QPARAMS to contain "query" node
 ; .QUERY will contain query parameters as subscripts: QUERY("name")=value
 N I,X,NAME,VALUE
 F I=1:1:$L(QPARAMS,"&") D
 . S X=$$URLDEC^%webutils($P(QPARAMS,"&",I))
 . S NAME=$P(X,"="),VALUE=$P(X,"=",2,999)
 . I $L(NAME) S QUERY(NAME)=VALUE
 Q
BODYASSTR(BODY)
 N BSTR S BSTR=""
 N AT F AT=0:0 S AT=$O(BODY(AT)) Q:'AT  S BSTR=BSTR_BODY(AT)
 Q BSTR
 ;
MATCH(ROUTINE,ARGS,PARAMS,AUTHNODE) ; evaluate paths in sequence until match found (else 404)
 ; Also does authentication and authorization
 ; TODO: this needs some work so that it will accomodate patterns shorter than the path
 ; expects HTTPREQ to contain "path" and "method" nodes
 ; ROUTINE contains the TAG^ROUTINE to execute for this path, otherwise empty
 ; .ARGS will contain an array of resolved path arguments
 ; .PARAMS will contain whether the routine should be called with the default
 ;  argument structure of , it will either contain zero or the number of
 ;      default (no params specified)
 ;                      - PUT/POST (.HTTPARGS,.BODY,.HTTPRSP)
 ;                      - GET (.HTTPRSP,.HTTPARGS)
 ;
 S ROUTINE=""  ; Default. Routine not found. Error 404.
 ;
 ; If we have the %W file for mapping...
 IF ('$G(NOGBL)),$D(^%web(17.6001)) DO MATCHF(.ROUTINE,.ARGS,.PARAMS,.AUTHNODE)
 ;
 ; Using built-in table if routine is still empty.
 I ROUTINE="" DO MATCHR(.ROUTINE,.ARGS)
 ;
 I $L($T(^SYNRGSHM))>0 D  ; RGNet DHP Shim
 . Q:'$D(^RGNET)
 . DO MATCHRG^SYNRGSHM(.ROUTINE,.ARGS,.AUTHNODE)
 ;
 ; If both of these fail, try matching against a file on the file system
 I ROUTINE="" DO MATCHFS(.ROUTINE)
 ;
 ; Okay. Do we have a routine to execute?
 I ROUTINE="" D SETERROR^%webutils(404,"Not Found") QUIT
 ;
 I $L($G(USERPASS)) S AUTHNODE=1
 I +$G(AUTHNODE) D  ; Web Service has authorization node
 . ;
 . I $L($G(USERPASS)) D  QUIT
 . . ; First, user must authenticate
 . . S HTTPRSP("auth")="Basic realm="""_HTTPREQ("header","host")_"""" ; Send Authentication Header
 . . N AUTHEN S AUTHEN=(USERPASS=$$DECODE64^%webutils($P($G(HTTPREQ("header","authorization"))," ",2))) ; Try to authenticate
 . . I 'AUTHEN D SETERROR^%webutils(401) QUIT  ; Unauthoirzed
 . ;
 . ; If there is no File 200, forget the whole thing. Pretend it didn't happen.
 . I '$D(^VA(200)) QUIT
 . ;
 . ; First, user must authenticate
 . S HTTPRSP("auth")="Basic realm="""_HTTPREQ("header","host")_"""" ; Send Authentication Header
 . N AUTHEN S AUTHEN=$$AUTHEN($G(HTTPREQ("header","authorization"))) ; Try to authenticate
 . I 'AUTHEN D SETERROR^%webutils(401) QUIT  ; Unauthoirzed
 . ;
 . ; DEBUG.ASSERT that DUZ is greater than 0
 . I $G(DUZ)'>0 S $EC=",U-NO-DUZ,"
 . ;
 . ; Then user must have security key
 . N KEY S KEY=$P(AUTHNODE,"^",2)    ; Get Key pointer
 . I KEY S KEY=$P($G(^DIC(19.1,KEY,0)),"^") ; Get Key name from Security Key file
 . I $L(KEY),'$D(^XUSEC(KEY,DUZ)) D SETERROR^%webutils(405,"Missing security key "_KEY) QUIT  ; Method not allowed
 . K KEY
 . ;
 . ; And not have reverse security key
 . N RKEY S RKEY=$P(AUTHNODE,"^",3)  ; Get Key pointer
 . I RKEY S RKEY=$P($G(^DIC(19.1,RKEY,0)),"^") ; Get Reverse Key name from Security Key file
 . I $L(RKEY),$D(^XUSEC(RKEY,DUZ)) D SETERROR^%webutils(405,"Holding exclusive key "_RKEY) QUIT  ; Method not allowed
 . K RKEY
 . ;
 . ; And have access to the menu option indicated
 . N OPTION S OPTION=$P(AUTHNODE,"^",4)  ; Get Option pointer
 . I OPTION N OPTIONNM S OPTIONNM=$P($G(^DIC(19,OPTION,0)),"^") ; Get Option name from Option file
 . I OPTION,$L($T(ACCESS^XQCHK)),'$$ACCESS^XQCHK(DUZ,OPTION) D SETERROR^%webutils(405,"No access to option "_OPTIONNM)  ; Method not allowed
 . K OPTION,OPTIONNM
 QUIT
 ;
 ;
MATCHF(ROUTINE,ARGS,PARAMS,AUTHNODE) ; Match against a file...
 ; ^%web(17.6001,"B","GET","xml"
 N PATH S PATH=HTTPREQ("path")
 S:$E(PATH)="/" PATH=$E(PATH,2,$L(PATH))
 ;
 N METHOD S METHOD=HTTPREQ("method")
 I METHOD="HEAD" S METHOD="GET" ; just for here
 ;
 N DONE S DONE=0
 N PATH1 S PATH1=$$URLDEC^%webutils($P(PATH,"/",1),1) ; get first / piece of path; and decode.
 N PATTERN S PATTERN=PATH1  ; looper variable; start at first piece of path.
 I $D(^%web(17.6001,"B",METHOD,PATTERN)) D  ; if path isn't just a simple full path that already exists
 . S ROUTINE=$O(^%web(17.6001,"B",METHOD,PATTERN,""))
 E  D
 . ; Loop through patterns. Start with first piece of path. quit if $order took us off the deep end.
 . F  S PATTERN=$O(^%web(17.6001,"B",METHOD,PATTERN)) Q:PATTERN=""  Q:PATH1'=$E(PATTERN,1,$L(PATH1))  D  Q:DONE
 . . ;
 . . I $E(PATTERN)="/" S PATTERN=$E(PATTERN,2,$L(PATTERN))
 . . ;
 . . ; TODO: only matches 1st piece then *. Second piece can be different.
 . . N I F I=2:1:$L(PATTERN,"/") D
 . . . N PATTSEG S PATTSEG=$$URLDEC^%webutils($P(PATTERN,"/",I),1) ; pattern Segment url-decoded
 . . . I PATTSEG="*" S ARGS("*")=$P(PATH,"/",I,999) QUIT
 . . ;
 . . I $D(ARGS("*")) S DONE=1 QUIT  ; We are done if we found the *
 . . ;
 . . I $L(PATTERN,"/")'=$L(PATH,"/") QUIT  ; not the same number of pieces; quit.
 . . K ARGS
 . . N FAIL S FAIL=0
 . . N I F I=2:1:$L(PATH,"/") D  Q:FAIL  ; we have matched the first piece; now, do every piece after that.
 . . . N PATHSEG S PATHSEG=$$URLDEC^%webutils($P(PATH,"/",I),1)  ; Path Segment url-decoded
 . . . N PATTSEG S PATTSEG=$$URLDEC^%webutils($P(PATTERN,"/",I),1) ; pattern Segment url-decoded
 . . . I $E(PATTSEG)'="{" S FAIL=($$LOW^%webutils(PATHSEG)'=$$LOW^%webutils(PATTSEG)) Q  ; if not mumps pattern, just string equality
 . . . S PATTSEG=$E(PATTSEG,2,$L(PATTSEG)-1) ; else, extract pattern by getting rid of curly braces
 . . . N ARGUMENT,TEXT S ARGUMENT=$P(PATTSEG,"?"),TEST=$P(PATTSEG,"?",2) ; get pattern match
 . . . I $L(TEST) S FAIL=(PATHSEG'?@TEST) Q:FAIL  ; run pattern match
 . . . S ARGS(ARGUMENT)=PATHSEG  ; if pattern matches, put into arguments hopper.
 . . ;
 . . Q:FAIL  ; last loop failed to find a match
 . . ;
 . . ; At this point, none of the stuff failed. We can tell the initial loop that we are done.
 . . S DONE=1
 Q:PATH1'=$E(PATTERN,1,$L(PATH1))
 S ROUTINE=$O(^%web(17.6001,"B",METHOD,PATTERN,""))
 N IEN S IEN=$O(^%web(17.6001,"B",METHOD,PATTERN,ROUTINE,""))
 I $O(^%web(17.6001,IEN,"PARAMS",0)) M PARAMS=^%web(17.6001,IEN,"PARAMS")
 S AUTHNODE=$G(^%web(17.6001,IEN,"AUTH"))
 QUIT
 ;
 ;
 ;
MATCHR(ROUTINE,ARGS) ; Match against this routine
 N METHOD S METHOD=HTTPREQ("method")
 I METHOD="HEAD" S METHOD="GET" ; just for here
 N PATH S PATH=HTTPREQ("path")
 S:$E(PATH)="/" PATH=$E(PATH,2,$L(PATH))
 N SEQ,PATMETHOD
 N DONE S DONE=0
 F SEQ=1:1 S PATTERN=$P($T(URLMAP+SEQ^%weburl),";;",2,99) Q:PATTERN="zzzzz"  D  Q:DONE
 . K ARGS
 . S ROUTINE=$P(PATTERN," ",3),PATMETHOD=$P(PATTERN," "),PATTERN=$P(PATTERN," ",2),FAIL=0
 . I $E(PATTERN)="/" S PATTERN=$E(PATTERN,2,$L(PATTERN))
 . I $L(PATTERN,"/")'=$L(PATH,"/") S ROUTINE="" Q  ; must have same number segments
 . F I=1:1:$L(PATH,"/") D  Q:FAIL
 . . S PATHSEG=$$URLDEC^%webutils($P(PATH,"/",I),1)
 . . S PATTSEG=$$URLDEC^%webutils($P(PATTERN,"/",I),1)
 . . I $E(PATTSEG)'="{" S FAIL=($$LOW^%webutils(PATHSEG)'=$$LOW^%webutils(PATTSEG)) Q
 . . S PATTSEG=$E(PATTSEG,2,$L(PATTSEG)-1) ; get rid of curly braces
 . . S ARGUMENT=$P(PATTSEG,"?"),TEST=$P(PATTSEG,"?",2)
 . . I $L(TEST) S FAIL=(PATHSEG'?@TEST) Q:FAIL
 . . S ARGS(ARGUMENT)=PATHSEG
 . I 'FAIL I PATMETHOD'=METHOD S FAIL=1
 . S:FAIL ROUTINE="" S:'FAIL DONE=1
 QUIT
 ;
MATCHFS(ROUTINE) ; Match against the file system
 N ARGS S ARGS("*")=$E(HTTPREQ("path"),2,9999)
 D FILESYS^%webapi(.HTTPRSP,.ARGS)
 I $O(HTTPRSP(0)) S ROUTINE="FILESYS^%webapi"
 quit
 ;
SENDATA ; write out the data as an HTTP response
 ; expects HTTPERR to contain the HTTP error code, if any
 ; RSPTYPE=1  local variable
 ; RSPTYPE=2  data in ^TMP($J)
 ;
 N %WBUFF S %WBUFF="" ; Write Buffer
 ;
 ; DKM - Send raw data.
 I $G(HTTPRSP("raw")) D  Q
 . N ARY,X,L
 . S ARY=$NA(@HTTPRSP),X=ARY,L=$QL(ARY)
 . F  S X=$Q(@X) Q:'$L(X)  Q:$NA(@X,L)'=ARY  D W(@X)
 . D FLUSH
 . K @ARY
 N SIZE,RSPTYPE,PREAMBLE,START,LIMIT
 S RSPTYPE=$S($E($G(HTTPRSP))'="^":1,$D(HTTPRSP("pageable")):3,1:2)
 I RSPTYPE=1 S SIZE=$$VARSIZE^%webutils(.HTTPRSP)
 I RSPTYPE=2 S SIZE=$$REFSIZE^%webutils(.HTTPRSP)
 ;
 ; TODO: Handle 201 responses differently (change simple OK to created)
 ;
 D W($$RSPLINE()_$C(13,10)) ; Status Line (200, 404, etc)
 D W("Date: "_$$GMT^%webutils_$C(13,10)) ; RFC 1123 date
 I $D(HTTPREQ("location")) D W("Location: "_HTTPREQ("location")_$C(13,10))  ; Response Location
 I $D(HTTPRSP("auth")) D W("WWW-Authenticate: "_HTTPRSP("auth")_$C(13,10)) K HTTPRSP("auth") ; Authentication
 I $D(HTTPRSP("cache")) D W("Cache-Control: max-age="_HTTPRSP("cache")_$C(13,10)) K HTTPRSP("cache") ; Browser caching
 I $D(HTTPRSP("mime")) D  ; Stack $TEST for the ELSE below
 . D W("Content-Type: "_HTTPRSP("mime")_$C(13,10)) K HTTPRSP("mime") ; Mime-type
 E  D W("Content-Type: application/json; charset=utf-8"_$C(13,10))
 ;
 ; Access-Control-Allow-Origin :- specifies either a single origin, which tells browsers to allow that origin to access the resource;
 ;        or else  for requests without credentials  the "*" wildcard, to tell browsers to allow any origin to access the resource
 ; Access-Control-Max-Age :- indicates how long the results of a preflight request can be cached
 ; Access-Control-Allow-Credentials :- indicates whether or not the response to the request can be exposed when the credentials flag is true
 ; Access-Control-Allow-Methods :- specifies the method or methods allowed when accessing the resource
 ; Access-Control-Allow-Headers :- is used in response to a preflight request to indicate which HTTP headers can be used when making the actual request.
 ;
 ; Add CORS headers
 I $G(CORS("enabled"))="Y" D
 . I $G(HTTPREQ("method"))="OPTIONS" D
 . . D W("Access-Control-Allow-Credentials: "_CORS("credentials")_$C(13,10))
 . . D W("Access-Control-Allow-Methods: "_CORS("method")_$C(13,10))
 . . D W("Access-Control-Allow-Headers: "_CORS("header")_$C(13,10))
 . . D W("Access-Control-Max-Age: "_CORS("maxAge")_$C(13,10))
 . D W("Access-Control-Allow-Origin: "_CORS("origin")_$C(13,10))
 ;
 I $P($SY,",")=47,'$G(NOGZIP),$G(HTTPREQ("header","accept-encoding"))["gzip" GOTO GZIP  ; If on GT.M, and we can zip, let's do that!
 ;
 D W("Content-Length: "_SIZE_$C(13,10)_$C(13,10))
 I 'SIZE!(HTTPREQ("method")="HEAD") D FLUSH Q  ; flush buffer and quit if empty
 ;
 N I,J
 I RSPTYPE=1 D            ; write out local variable
 . I $D(HTTPRSP)#2 D W(HTTPRSP)
 . I $D(HTTPRSP)>1 S I=0 F  S I=$O(HTTPRSP(I)) Q:'I  D W(HTTPRSP(I))
 I RSPTYPE=2 D            ; write out global using indirection
 . I $D(@HTTPRSP)#2 D W(@HTTPRSP)
 . ; I $D(@HTTPRSP)>1 S I=0 F  S I=$O(@HTTPRSP@(I)) Q:'I  D W(@HTTPRSP@(I))
 . I $D(@HTTPRSP)>1 D
 . . N ORIG,OL S ORIG=HTTPRSP,OL=$QL(HTTPRSP) ; Orig, Orig Length
 . . N HTTPEXIT S HTTPEXIT=0
 . . F  D  Q:HTTPEXIT
 . . . S HTTPRSP=$Q(@HTTPRSP)
 . . . D:$G(HTTPRSP)'="" W(@HTTPRSP)
 . . . I $G(HTTPRSP)="" S HTTPEXIT=1
 . . . E  I $G(@HTTPRSP),$G(@ORIG),$NA(@HTTPRSP,OL)'=$NA(@ORIG,OL) S HTTPEXIT=1
 . . ; End ~ vertical rewrite
 . . S HTTPRSP=ORIG
 D FLUSH ; flush buffer
 Q
 ;
W(DATA) ; EP to write data
 ; ZEXCEPT: %WBUFF - Buffer in Symbol Table
 I $P($SY,",")=47,$ZL(%WBUFF)+$ZL(DATA)>32000 D FLUSH
 I $L($SY,":")=2,$L(%WBUFF)+$L(DATA)>32000 D FLUSH
 S %WBUFF=%WBUFF_DATA
 QUIT
 ;
FLUSH ; EP to flush written data
 ; ZEXCEPT: %WBUFF - Buffer in Symbol Table
 W %WBUFF,!
 S %WBUFF=""
 QUIT
 ;
GZIP ; EP to write gzipped content
 ; Nothing to write?
 I 'SIZE D  QUIT  ; nothing to write!
 . D W("Content-Length: 0"_$C(13,10,13,10))
 . D FLUSH
 ;
 ; zip away - Open gzip and write to it, then read back the zipped file.
 N OLDIO S OLDIO=$IO
 n file
 i $ZV["Linux" s file="/dev/shm/mws-"_$J_"-"_$R(999999)_".dat"
 e  s file="/tmp/mws-"_$J_"-"_$R(999999)_".dat"
 o file:(newversion:stream:nowrap:chset="M")
 u file
 ;
 ; Write out data
 N I,J
 I RSPTYPE=1 D            ; write out local variable
 . I $D(HTTPRSP)#2 W HTTPRSP
 . I $D(HTTPRSP)>1 S I=0 F  S I=$O(HTTPRSP(I)) Q:'I  W HTTPRSP(I)
 I RSPTYPE=2 D            ; write out global using indirection
 . I $D(@HTTPRSP)#2 W @HTTPRSP
 . I $D(@HTTPRSP)>1 S I=0 F  S I=$O(@HTTPRSP@(I)) Q:'I  W @HTTPRSP@(I)
 ;
 ; Close
 c file
 ;
 O "D":(shell="/bin/sh":command="gzip "_file:parse):0:"pipe"
 U "D" C "D"
 ;
 n ZIPPED
 o file_".gz":(readonly:fixed:nowrap:recordsize=255:chset="M"):0
 u file_".gz"
 n i f i=1:1 read ZIPPED(i):0  q:$zeof
 U OLDIO c file_".gz":delete
 ;
 ; Calculate new size (reset SIZE first)
 S SIZE=0
 N I F I=0:0 S I=$O(ZIPPED(I)) Q:'I  S SIZE=SIZE+$ZL(ZIPPED(I))
 ;
 ; Write out the content headings for gzipped file.
 D W("Content-Encoding: gzip"_$C(13,10))
 D W("Content-Length: "_SIZE_$C(13,10)_$C(13,10))
 I HTTPREQ("method")="HEAD" D FLUSH Q  ; flush buffer and quit if empty
 ;
 N I F I=0:0 S I=$O(ZIPPED(I)) Q:'I  D W(ZIPPED(I))
 D FLUSH
 ;
 QUIT
 ;
RSPERROR ; set response to be an error response
 Q:$G(NOGBL)
 D encode^%webjson("^TMP(""HTTPERR"",$J,1)","^TMP(""HTTPERR"",$J,""JSON"")")
 S HTTPRSP="^TMP(""HTTPERR"",$J,""JSON"")"
 K HTTPRSP("pageable")
 Q
RSPLINE() ; writes out a response line based on HTTPERR
 ; VEN/SMH: TODO: There ought to be a simpler way to do this!!!
 I '$G(HTTPERR),'$D(HTTPREQ("location")) Q "HTTP/1.1 200 OK"
 I '$G(HTTPERR),$D(HTTPREQ("location")) Q "HTTP/1.1 201 Created"
 I $G(HTTPERR)=400 Q "HTTP/1.1 400 Bad Request"
 I $G(HTTPERR)=401 Q "HTTP/1.1 401 Unauthorized"
 I $G(HTTPERR)=404 Q "HTTP/1.1 404 Not Found"
 I $G(HTTPERR)=405 Q "HTTP/1.1 405 Method Not Allowed"
 Q "HTTP/1.1 500 Internal Server Error"
 ;
AUTHEN(HTTPAUTH) ; Authenticate User against VISTA from HTTP Authorization Header
 ;
 ; We only support Basic authentication right now
 N P1,P2 S P1=$P(HTTPAUTH," "),P2=$P(HTTPAUTH," ",2)
 I $$UP^%webutils(P1)'="BASIC" Q 0 ; We don't support that authentication
 ;
 ; Decode Base64 encoded un:pwd
 N ACVC S ACVC=$$DECODE64^%webutils(P2)
 S ACVC=$TR(ACVC,":",";") ; switch the : so that it's now ac;vc
 ; TODO: Check if there is more than one colon in the ACVC
 ;
 ; Sign-on
 N IO S IO=$P
 D SETUP^XUSRB() ; Only partition set-up; No single sign-on or CAPRI
 N RTN D VALIDAV^XUSRB(.RTN,$$ENCRYP^XUSRB1(ACVC)) ; sign-on call
 I RTN(0)>0,'RTN(2) Q 1 ; Sign on successful!
 I RTN(0)=0,RTN(2) Q 0  ; Verify Code must be changed NOW!
 I $L(RTN(3)) Q 0  ; Error Message
 ;
 ; TODO: Division Selection
 QUIT 0
 ;
 ; Portions of this code are public domain, but it was extensively modified
 ; Copyright 2013-2019 Sam Habiel
 ; Copyright 2018-2019 Christopher Edwards
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%webjsonDecodeTest
%webjsonDecodeTest ;SLC/KCM -- Unit tests for JSON decoding;2019-07-16  2:17 PM
 ;
 d EN^%ut($t(+0),3)
 quit
 ;
STARTUP  ; Run once before all tests
 if $p($sy,",")=47 VIEW "TRACE":1:"^%wtrace"
 Q
SHUTDOWN ; Run once after all tests
 if $p($sy,",")=47 VIEW "TRACE":0:"^%wtrace"
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D CHKEQ^%ut(EXPECT,ACTUAL)
 Q
 ;
JSONUES ;; @TEST unescape JSON encoded string
 N X
 S X=$$UES^%webjson("String with \\ in the middle")
 D ASSERT("String with \ in the middle",X)
 S X=$$UES^%webjson("\\ is the first character of this string")
 D ASSERT("\ is the first character of this string",X)
 S X=$$UES^%webjson("The last character of this string is \\")
 D ASSERT("The last character of this string is \",X)
 S X=$$UES^%webjson("\\one\\two\\three\\")
 D ASSERT("\one\two\three\",X)
 S X=$$UES^%webjson("A vee shape: \\\/\tTABBED\tand line endings.\n\r\f")
 D ASSERT("A vee shape: \/"_$C(9)_"TABBED"_$C(9)_"and line endings."_$C(10,13,12),X)
 S X=$$UES^%webjson("\""This text is quoted\""")
 D ASSERT("""This text is quoted""",X)
 S X=$$UES^%webjson("This text contains an embedded\u001A control character")
 D ASSERT("This text contains an embedded"_$C(26)_" control character",X)
 S X=$$UES^%webjson("This contains tab\t and control\u0016 characters")
 D ASSERT("This contains tab"_$C(9)_" and control"_$C(22)_" characters",X)
 Q
SPLITA ;; @TEST JSON input with escaped characters on single line (uses BUILD)
 N JSON,Y,ERR,ESC
 ; V4W/DLW - Removed "string" from SPLIT+3^%webjsonTestData1
 S ESC="this contains \and other escaped characters such as "_$c(10)
 ; V4W/DLW - Removed "a piece of" from SPLIT+5^%webjsonTestData1
 S ESC=ESC_"  and a few tabs "_$c(9,9,9,9)_" and ""quoted text"""
 D BUILD("SPLIT",.JSON)
 D ASSERT(0,$D(JSON(2)))
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(ESC,$G(Y("esc")))
 D ASSERT("this is a new line",$G(Y("next")))
 D ASSERT("this is a string that goes across two lines",$G(Y("wp")))
 D ASSERT("here is another string",$G(Y("nextLineQuote")))
 Q
SPLITB ;; @TEST multiple line JSON input with lines split across tokens (uses BUILDA)
 N JSON,Y,ERR,ESC
 ; V4W/DLW - Removed "string" from SPLIT+3^%webjsonTestData1
 S ESC="this contains \and other escaped characters such as "_$c(10)
 ; V4W/DLW - Removed "a piece of" from SPLIT+5^%webjsonTestData1
 S ESC=ESC_"  and a few tabs "_$c(9,9,9,9)_" and ""quoted text"""
 D BUILDA("SPLIT",.JSON)
 D ASSERT(1,$D(JSON(2)))
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(ESC,$G(Y("esc")))
 D ASSERT("this is a new line",$G(Y("next")))
 D ASSERT("this is a string that goes across two lines",$G(Y("wp")))
 D ASSERT("here is another string",$G(Y("nextLineQuote")))
 Q
SPLITC ;; @TEST multiple line JSON input with lines split inside boolean value
 N JSON,Y,ERR,ESC
 D BUILDA("SPLITC",.JSON)
 D ASSERT(1,$D(JSON(4)))
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("false",$G(Y("completed")))
 D ASSERT("urn:va:user:2C0A:1134",$G(Y("ownerCode")))
 D ASSERT("SQA,ONE",$G(Y("assignToName")))
 D ASSERT("urn:va:user:2C0A:1134",$G(Y("assignToCode")))
 Q
SPLITD ;; @TEST multiple line JSON input with key split
 n json,y,err
 s json(1)="{ ""boo"": ""foo"", ""code"" : ""22-2""}"
 d decode^%webjson("json","y","err")
 D ASSERT(0,$D(err))
 D ASSERT(y("code"),"22-2")
 n json,y,err
 s json(1)="{ ""boo"": ""foo"", ""c"
 s json(2)="ode"": ""22-2""}"
 d decode^%webjson("json","y","err")
 D ASSERT(0,$D(err))
 D ASSERT(y("code"),"22-2")
 quit
 ;
LONG ;; @TEST long document that must be saved across extension nodes
 N JSON,Y,ERR,I,LINE,CCNT1,CCNT2
 S JSON(1)="{""title"":""long document"",""size"":""rather large"",""document"":"""
 S LINE="This is a line of text intended to test longer documents.\r\n  It will be repeated so that there are several nodes that must be longer than 4000 kilobytes."
 F I=2:1:100 S JSON(I)=LINE
 S JSON(101)="\r\nThis line ends with a control character split over to the next line.\u0"
 S JSON(102)="016The last line has a control character.\u001A"
 S JSON(103)=""",""author"":""WINDED,LONG""}"
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 S CCNT1=0 F I=2:1:102  S CCNT1=CCNT1+$L(JSON(I))
 S CCNT2=$L(Y("document")) F I=1:1:199 S CCNT2=CCNT2+$L(Y("document","\",I))
 D ASSERT(210,CCNT1-CCNT2) ; 100 \r\n->$C(13,10), 1 \u001a->$C(26), 1 \u0016->$C(22) = 210 less chars
 D ASSERT(59,$L(Y("document")))
 D ASSERT(94,$L(Y("document","\",3)))
 D ASSERT(1,Y("document","\",198)[$C(22))
 D ASSERT($C(26),$E(Y("document","\",199),$L(Y("document","\",199))))
 D ASSERT(0,$D(Y("document",4)))
 D ASSERT("WINDED,LONG",Y("author"))
 D ASSERT("rather large",Y("size"))
 Q
FRAC ;; @TEST multiple lines with fractional array elements
 ;; {"title":"my array of stuff", "count":3, "items": [
 ;; {"name":"red", "rating":"ok"},
 ;; {"name":"blue", "rating":"good"},
 ;; {"name":"purple", "rating":"outstanding"}
 ;; ]}
 N JSON,Y,ERR
 S JSON(0)=$P($T(FRAC+1),";;",2,99)
 S JSON(.5)=$P($T(FRAC+2),";;",2,99)
 S JSON(1)=$P($T(FRAC+3),";;",2,99)
 S JSON(1.1)=$P($T(FRAC+4),";;",2,99)
 S JSON(1.2)=$P($T(FRAC+5),";;",2,99)
 S JSON("JUNK")="Junk non-numeric node -- this should be ignored"
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("purple",Y("items",3,"name"))
 Q
VALONLY ;; @TEST passing in value only -- not array
 N JSON,Y,ERR
 S JSON=$P($T(VALONLY+1^%webjsonTestData1),";;",2,999)
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("urn:va:param:F484:1120:VPR USER PREF:1120",Y("uid"))
 D ASSERT("north",Y("vals","cpe.patientpicker.loc"))
 Q
NUMERIC ;; @TEST passing in numeric types and strings
 N JSON,Y,ERR
 S JSON=$P($T(NUMERIC+1^%webjsonTestData1),";;",2,999)
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(234567,+Y("count")) ; make sure it's numeric
 D ASSERT(20120919,Y("hl7Time"))
 D ASSERT(1,$D(Y("hl7Time","\s")))
 D ASSERT("722.10",Y("icd"))
 D ASSERT(0,+Y("icd")="722.10") ; make sure it's a string
 Q
NEARZERO ;; @TEST decoding numbers near 0
 ;; {"x":0.42, "y":-0.44, "s":"0.5", "t":"-0.6"}
 N JSON,JSON2,Y,ERR
 S JSON=$P($T(NEARZERO+1),";;",2,999)
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(1,$D(Y("x","\n")))
 D ASSERT(1,$D(Y("y","\n")))
 D ASSERT(.42,Y("x"))
 D ASSERT(-.44,Y("y"))
 D ASSERT(0,Y("s")=.5)
 D ASSERT(0,Y("t")=-.6)
 Q
BADQUOTE ;; @TEST poorly formed JSON (missing close quote on LABEL)
 N JSON,Y,ERR
 D BUILD("BADQUOTE",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
BADSLASH ;; @TEST poorly formed JSON (non-escaped backslash)
 N JSON,Y,ERR
 D BUILD("BADSLASH",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
BADBRACE ;; @TEST poorly formed JSON (Extra Brace)
 N JSON,Y,ERR
 D BUILD("BADBRACE",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
BADCOMMA ;; @TEST poorly formed JSON (Extra Comma)
 N JSON,Y,ERR
 D BUILD("BADCOMMA",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
PSNUM ;; @TEST subjects that look like a numbers shouldn't be encoded as numbers
 N JSON,Y,ERR
 D BUILD("PSNUM",.JSON)
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(Y("0.85,0.01","AUDIT"),"TEST1")
 D ASSERT(Y("0.85,0.02","AUDIT"),"TEST3")
 D ASSERT(Y("0.85,0.03","AUDIT"),"TEST5")
 Q
NUMLABEL ;; @TEST label that begins with numeric
 N JSON,Y,ERR
 D BUILD("NUMLABEL",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(46570,Y("syncStatusByVistaSystemId","9E99","dfn"))
 Q
PURENUM ;; @TEST label that is purely numeric
 N JSON1,JSON2,Y,RSLT,ERR
 D BUILD("PURENUM1",.JSON1)
 D DECODE^%webjson("JSON1","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(100,Y("syncStatusByVistaSystemId","""1234","domainExpectedTotals","bar","total"))
 D ASSERT(1,$D(Y("forOperational","\s"))) ; appears boolean but really a string
 D ENCODE^%webjson("Y","JSON2","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(1,($L(JSON1(1))=($L(JSON2(1))+$L(JSON2(2))+$L(JSON2(3)))))
 D ASSERT(1,(JSON2(2)[":{""1234"":{"))
 D BUILD("PURENUM2",.RSLT)
 D ASSERT(RSLT(1),JSON2(1)_JSON2(2)_JSON2(3))
 Q
STRTYPES ;; @TEST strings that may be confused with other types
 N JSON,Y,ERR
 D BUILD("STRTYPES",.JSON)
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(1,$D(Y("syncStatusByVistaSystemId","""1234","syncComplete","\s")))
 Q
ESTRING ;; @TEST a value that looks like an exponents, other numerics
 N JSON,Y,JSON2,ERR
 D BUILD("ESTRING",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("32E497ABC",Y("b"))
 D ASSERT(.123,Y("c"))
 D ASSERT(3E22,Y("g"))
 D ASSERT(1,$D(Y("g","\n")))
 D ASSERT(0,Y("h")=2E8)
 D ENCODE^%webjson("Y","JSON2","ERR")
 D ASSERT(1,JSON(1)=(JSON2(1)_JSON2(2)))
 Q
SAM1 ;; @TEST decode sample 1 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM1",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("file",$G(Y("menu","id")))
 D ASSERT("OpenDoc()",$G(Y("menu","popup","menuitem",2,"onclick")))
 Q
SAM2 ;; @TEST decode sample 2 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM2",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("XML",$G(Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",2)))
 D ASSERT("SGML",$G(Y("glossary","GlossDiv","GlossList","GlossEntry","SortAs")))
 Q
SAM3 ;; @TEST decode sample 3 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM3",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(500,$G(Y("widget","window","width")))
 D ASSERT("sun1.opacity = (sun1.opacity / 100) * 90;",$G(Y("widget","text","onMouseUp")))
 D ASSERT("Sample Konfabulator Widget",$G(Y("widget","window","title")))
 Q
SAM4 ;; @TEST decode sample 4 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM4",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(Y("web-app","servlet",6)))  ; should only be 5 servlets
 D ASSERT(1,$G(Y("web-app","servlet",5,"init-param","log")))
 D ASSERT("/usr/local/tomcat/logs/CofaxTools.log",$G(Y("web-app","servlet",5,"init-param","logLocation")))
 D ASSERT("/",$G(Y("web-app","servlet-mapping","cofaxCDS")))
 D ASSERT("/WEB-INF/tlds/cofax.tld",$G(Y("web-app","taglib","taglib-location")))
 Q
SAM5 ;; @TEST decode sample 5 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM5",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(Y("menu","items",23)))  ; should only be 22 items
 D ASSERT("About Adobe CVG Viewer...",$G(Y("menu","items",22,"label")))
 D ASSERT("null",$G(Y("menu","items",3)))
 Q
 ;
MAXNUM ;; @TEST encode large string that looks like number
 N I,X,Y,JSON,ERR,OUT
 F I=0:1 S X=$P($T(MAXNUM+(I+1)^%webjsonTestData1),";;",2,999) Q:X="#####"  S JSON(I)=X
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(217,$L(Y("taskName","\",1)))
 D ENCODE^%webjson("Y","OUT","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(1,$L(OUT(1))=93)
 D ASSERT(1,OUT(3)["""facilityCode"":""500")
 Q
ESCQ ;; @TEST escaped quote across lines
 N JSON,Y,ERR
 D BUILDA("ESCQ",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(55,$L(Y("comments")))
 K JSON,Y,ERR
 D BUILDA("ESCQ2",.JSON) D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(42,$L(Y("bjw")))
 Q
KEYQUOTE ;; @TEST keys with quotes
 N ENCODE,JSON,Y,ERR
 S JSON="{""a(1,3:\""\"")"":""AREG""}"
 D DECODE^%webjson("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("AREG",$G(Y("a(1,3:"""")")))
 K ERR
 D ENCODE^%webjson("Y","ENCODE","ERR")
 D ASSERT(ENCODE(1),JSON)
 Q
BUILD(TAG,JSON) ; Build array of strings in JSON for TAG
 N X,I,LINE
 S LINE=1,JSON(LINE)=""
 F I=1:1 S X=$E($T(@TAG+I^%webjsonTestData1),4,999) Q:X="#####"  D
 . I $L(JSON(LINE))+$L(X)>4000 S LINE=LINE+1,JSON(LINE)=""
 . S JSON(LINE)=JSON(LINE)_X
 Q
BUILDA(TAG,JSON) ; Build array of string in JSON with splits preserved
 N X,I
 F I=1:1 S X=$E($T(@TAG+I^%webjsonTestData1),4,999) Q:X="#####"  S JSON(I)=X
 Q
 ;
 ; Portions of this code are public domain, but it was extensively modified
 ; Copyright 2016 Accenture Federal Services
 ; Copyright 2013-2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%webjsonTestData2
VPRJUJ02 ;SLC/KCM -- Sample data for JSON encoding;Feb 07, 2019@10:58
 ;
 ;
 ; Portions of this code are public domain, but it was extensively modified
 ; Copyright 2016 Accenture Federal Services
 ; Copyright 2013-2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.
 ;
 ; expected return data values
 ;
BASIC ;; Basic object
 ;;{"myObj":{"array":["one","two","three"],"booleanF":false,"booleanT":true,"nullValue":null,"numeric":3.1416,"subObject":{"fieldA":"hello","fieldB":"world"}}}
VALS ;; Simple values only object
 ;;{"arr":["apple","orange","pear",{"obj":"4th array item is object"}],"bool1":true,"num1":2.1e3,"prop1":"property1"}
LONG ;; Object with continuation nodes
 ;;{"note":"This is the first line of the note.  Here are \"quotes\" and a \\ and a \/.\nAdditional Line #1, this will extend the line out to at least 78 characters.\nAdditional Line #2,
NODES ;; Nodes preformatted as JSON
 ;;{"value": "New", "onclick": "CreateNewDoc()"}
 ;;{"value": "Open", "onclick": "OpenDoc()"}
 ;;{"value": "Close", "onclick": "CloseDoc()"}
 ;;{"data":"Click Here","size":36,"style":"bold","name":"text1","hOffset":250,"vOffset":100,"alignment":"center","onMouseUp":"sun1.opacity = (sun1.opacity / 100) * 90;"}
PRE ;; Adding already encoded values to object
 ;;{"count":3,"menu":[{"value": "New", "onclick": "CreateNewDoc()"},{"value": "Open", "onclick": "OpenDoc()"},{"value": "Close", "onclick": "CloseDoc()"}],"template":
 ;;{"data":"Click Here","size":36,"style":"bold","name":"text1","hOffset":250,"vOffset":100,"alignment":"center","onMouseUp":"sun1.opacity = (sun1.opacity / 100) * 90;"}}
WPOUT ;; WP field encoded as JSON
 ;;{"dob":"APR 7,1935","gender":"MALE","lastVitals":{"height":{"lastDone":"Aug 24, 2009","value":190},"weight":{"lastDone":"Jul 01, 2011","value":210}},"name":"AVIVAPATIENT,THIRTY","patDemDetails":{"text":"               COORDINATING
 ;; MASTER OF RECORD: ABILENE (CAA)\r\n Address: Any Street                    Temporary: NO TEMPORARY ADDRESS\r\n         Any Town,WV 99998-0071\r\n         \r\n  County: UNSPECIFIED                     From\/To: NOT APPLICABLE\r\n"},
 ;;"uid":"urn:va:F484:8:patient:8"}
LTZERO ;; Leading and trailing zeros
 ;;{"code":".77","count":737,"errors":0,"icd":"626.00","price":0.65,"ssn":"000427930"}
STRINGS ;; strings that look like numbers
 ;;{"count":234567,"hl7Time":"20120919","icd":"722.10","name":"Duck,Donald"}
EX1OUT ;; JSON.org example #1 target
 ;;{"menu":{"id":"file","popup":{"menuitem":[{"onclick":"CreateNewDoc()","value":"New"},{"onclick":"OpenDoc()","value":"Open"},{"onclick":"CloseDoc()","value":"Close"}]},"value":"File"}}
EX2OUT ;; JSON.org example #2 target
 ;;{"glossary":{"GlossDiv":{"GlossList":{"GlossEntry":{"Abbrev":"ISO 8879:1986","Acronym":"SGML","GlossDef":{"GlossSeeAlso":["GML","XML"],"para":"A meta-markup language, used to create markup languages such as DocBook."}
 ;;,"GlossSee":"markup","GlossTerm":"Standard Generalized Markup Language","ID":"SGML","SortAs":"SGML"}},"title":"S"},"title":"example glossary"}}
EX3OUT ;; JSON.org example #3 target
 ;;{"widget":{"debug":"on","image":{"alignment":"center","hOffset":250,"name":"sun1","src":"Images\/Sun.png","vOffset":250},"text":{"alignment":"center","data":"Click Here","hOffset":250,"name":"text1","onMouseUp":
 ;;"sun1.opacity = (sun1.opacity \/ 100) * 90;","size":36,"style":"bold","vOffset":100},"window":{"height":500,"name":"main_window","title":"Sample Konfabulator Widget","width":500}}}
EX4OUT ;; JSON.org example #4 target
 ;;{"web-app":{"servlet":[{"init-param":{"cachePackageTagsRefresh":60,"cachePackageTagsStore":200,"cachePackageTagsTrack":200,"cachePagesDirtyRead":10,"cachePagesRefresh":10,"cachePagesStore":100,"cachePagesTrack":200,
 ;
 ; data values to test long text field input
 ;
WP ;; object with word processing field
 ;;Y("dob")="APR 7,1935"
 ;;Y("gender")="MALE"
 ;;Y("lastVitals","height","lastDone")="Aug 24, 2009"
 ;;Y("lastVitals","height","value")=190
 ;;Y("lastVitals","weight","lastDone")="Jul 01, 2011"
 ;;Y("lastVitals","weight","value")=210
 ;;Y("name")="AVIVAPATIENT,THIRTY"
 ;;Y("patDemDetails","text","\",6)="               COORDINATING MASTER OF RECORD: ABILENE (CAA)"_$C(13,10)
 ;;Y("patDemDetails","text","\",7)=" Address: Any Street                    Temporary: NO TEMPORARY ADDRESS"_$C(13,10)
 ;;Y("patDemDetails","text","\",8)="         Any Town,WV 99998-0071"_$C(13,10)
 ;;Y("patDemDetails","text","\",9)="         "_$C(13,10)
 ;;Y("patDemDetails","text","\",10)="  County: UNSPECIFIED                     From/To: NOT APPLICABLE"_$C(13,10)
 ;;Y("uid")="urn:va:F484:8:patient:8"
 ;;zzzzz
 ;
 ; data values for JSON.ORG examples rendered as M arrays
 ;
EX1IN ;; JSON.org example #1
 ;;Y("menu","id")="file"
 ;;Y("menu","popup","menuitem",1,"onclick")="CreateNewDoc()"
 ;;Y("menu","popup","menuitem",1,"value")="New"
 ;;Y("menu","popup","menuitem",2,"onclick")="OpenDoc()"
 ;;Y("menu","popup","menuitem",2,"value")="Open"
 ;;Y("menu","popup","menuitem",3,"onclick")="CloseDoc()"
 ;;Y("menu","popup","menuitem",3,"value")="Close"
 ;;Y("menu","value")="File"
 ;;zzzzz
EX2IN ;; JSON.org example #2
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","Abbrev")="ISO 8879:1986"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","Acronym")="SGML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",1)="GML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",2)="XML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","para")="A meta-markup language, used to create markup languages such as DocBook."
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossSee")="markup"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossTerm")="Standard Generalized Markup Language"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","ID")="SGML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","SortAs")="SGML"
 ;;Y("glossary","GlossDiv","title")="S"
 ;;Y("glossary","title")="example glossary"
 ;;zzzzz
EX3IN ;; JSON.org example #3
 ;;Y("widget","debug")="on"
 ;;Y("widget","image","alignment")="center"
 ;;Y("widget","image","hOffset")=250
 ;;Y("widget","image","name")="sun1"
 ;;Y("widget","image","src")="Images/Sun.png"
 ;;Y("widget","image","vOffset")=250
 ;;Y("widget","text","alignment")="center"
 ;;Y("widget","text","data")="Click Here"
 ;;Y("widget","text","hOffset")=250
 ;;Y("widget","text","name")="text1"
 ;;Y("widget","text","onMouseUp")="sun1.opacity = (sun1.opacity / 100) * 90;"
 ;;Y("widget","text","size")=36
 ;;Y("widget","text","style")="bold"
 ;;Y("widget","text","vOffset")=100
 ;;Y("widget","window","height")=500
 ;;Y("widget","window","name")="main_window"
 ;;Y("widget","window","title")="Sample Konfabulator Widget"
 ;;Y("widget","window","width")=500
 ;;zzzzz
EX4IN ;; JSON.org example #4
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsRefresh")=60
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsStore")=200
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsTrack")=200
 ;;Y("web-app","servlet",1,"init-param","cachePagesDirtyRead")=10
 ;;Y("web-app","servlet",1,"init-param","cachePagesRefresh")=10
 ;;Y("web-app","servlet",1,"init-param","cachePagesStore")=100
 ;;Y("web-app","servlet",1,"init-param","cachePagesTrack")=200
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesRefresh")=15
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesStore")=50
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesTrack")=100
 ;;Y("web-app","servlet",1,"init-param","configGlossary:adminEmail")="ksm@pobox.com"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:installationAt")="Philadelphia, PA"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:poweredBy")="Cofax"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:poweredByIcon")="/images/cofax.gif"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:staticPath")="/content/static"
 ;;Y("web-app","servlet",1,"init-param","dataStoreClass")="org.cofax.SqlDataStore"
 ;;Y("web-app","servlet",1,"init-param","dataStoreConnUsageLimit")=100
 ;;Y("web-app","servlet",1,"init-param","dataStoreDriver")="com.microsoft.jdbc.sqlserver.SQLServerDriver"
 ;;Y("web-app","servlet",1,"init-param","dataStoreInitConns")=10
 ;;Y("web-app","servlet",1,"init-param","dataStoreLogFile")="/usr/local/tomcat/logs/datastore.log"
 ;;Y("web-app","servlet",1,"init-param","dataStoreLogLevel")="debug"
 ;;Y("web-app","servlet",1,"init-param","dataStoreMaxConns")=100
 ;;Y("web-app","servlet",1,"init-param","dataStoreName")="cofax"
 ;;Y("web-app","servlet",1,"init-param","dataStorePassword")="dataStoreTestQuery"
 ;;Y("web-app","servlet",1,"init-param","dataStoreTestQuery")="SET NOCOUNT ON;select test='test';"
 ;;Y("web-app","servlet",1,"init-param","dataStoreUrl")="jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon"
 ;;Y("web-app","servlet",1,"init-param","dataStoreUser")="sa"
 ;;Y("web-app","servlet",1,"init-param","defaultFileTemplate")="articleTemplate.htm"
 ;;Y("web-app","servlet",1,"init-param","defaultListTemplate")="listTemplate.htm"
 ;;Y("web-app","servlet",1,"init-param","jspFileTemplate")="articleTemplate.jsp"
 ;;Y("web-app","servlet",1,"init-param","jspListTemplate")="listTemplate.jsp"
 ;;Y("web-app","servlet",1,"init-param","maxUrlLength")=500
 ;;Y("web-app","servlet",1,"init-param","redirectionClass")="org.cofax.SqlRedirection"
 ;;Y("web-app","servlet",1,"init-param","searchEngineFileTemplate")="forSearchEngines.htm"
 ;;Y("web-app","servlet",1,"init-param","searchEngineListTemplate")="forSearchEnginesList.htm"
 ;;Y("web-app","servlet",1,"init-param","searchEngineRobotsDb")="WEB-INF/robots.db"
 ;;Y("web-app","servlet",1,"init-param","templateLoaderClass")="org.cofax.FilesTemplateLoader"
 ;;Y("web-app","servlet",1,"init-param","templateOverridePath")=""
 ;;Y("web-app","servlet",1,"init-param","templatePath")="templates"
 ;;Y("web-app","servlet",1,"init-param","templateProcessorClass")="org.cofax.WysiwygTemplate"
 ;;Y("web-app","servlet",1,"init-param","useDataStore")="true"
 ;;Y("web-app","servlet",1,"init-param","useJSP")="false"
 ;;Y("web-app","servlet",1,"servlet-class")="org.cofax.cds.CDSServlet"
 ;;Y("web-app","servlet",1,"servlet-name")="cofaxCDS"
 ;;Y("web-app","servlet",2,"init-param","mailHost")="mail1"
 ;;Y("web-app","servlet",2,"init-param","mailHostOverride")="mail2"
 ;;Y("web-app","servlet",2,"servlet-class")="org.cofax.cds.EmailServlet"
 ;;Y("web-app","servlet",2,"servlet-name")="cofaxEmail"
 ;;Y("web-app","servlet",3,"servlet-class")="org.cofax.cds.AdminServlet"
 ;;Y("web-app","servlet",3,"servlet-name")="cofaxAdmin"
 ;;Y("web-app","servlet",4,"servlet-class")="org.cofax.cds.FileServlet"
 ;;Y("web-app","servlet",4,"servlet-name")="fileServlet"
 ;;Y("web-app","servlet",5,"init-param","adminGroupID")=4
 ;;Y("web-app","servlet",5,"init-param","betaServer")="true"
 ;;Y("web-app","servlet",5,"init-param","dataLog")=1
 ;;Y("web-app","servlet",5,"init-param","dataLogLocation")="/usr/local/tomcat/logs/dataLog.log"
 ;;Y("web-app","servlet",5,"init-param","dataLogMaxSize")=""
 ;;Y("web-app","servlet",5,"init-param","fileTransferFolder")="/usr/local/tomcat/webapps/content/fileTransferFolder"
 ;;Y("web-app","servlet",5,"init-param","log")=1
 ;;Y("web-app","servlet",5,"init-param","logLocation")="/usr/local/tomcat/logs/CofaxTools.log"
 ;;Y("web-app","servlet",5,"init-param","logMaxSize")=""
 ;;Y("web-app","servlet",5,"init-param","lookInContext")=1
 ;;Y("web-app","servlet",5,"init-param","removePageCache")="/content/admin/remove?cache=pages&id="
 ;;Y("web-app","servlet",5,"init-param","removeTemplateCache")="/content/admin/remove?cache=templates&id="
 ;;Y("web-app","servlet",5,"init-param","templatePath")="toolstemplates/"
 ;;Y("web-app","servlet",5,"servlet-class")="org.cofax.cms.CofaxToolsServlet"
 ;;Y("web-app","servlet",5,"servlet-name")="cofaxTools"
 ;;Y("web-app","servlet-mapping","cofaxAdmin")="/admin/*"
 ;;Y("web-app","servlet-mapping","cofaxCDS")="/"
 ;;Y("web-app","servlet-mapping","cofaxEmail")="/cofaxutil/aemail/*"
 ;;Y("web-app","servlet-mapping","cofaxTools")="/tools/*"
 ;;Y("web-app","servlet-mapping","fileServlet")="/static/*"
 ;;Y("web-app","taglib","taglib-location")="/WEB-INF/tlds/cofax.tld"
 ;;Y("web-app","taglib","taglib-uri")="cofax.tld"
 ;;zzzzz

%webreq
%webreq ;SLC/KCM -- Listen for HTTP requests;2019-11-14  2:05 PM
 ;
 ; Listener Process ---------------------------------------
 ;
go ; start up REST listener with defaults
 N PORT S PORT=$G(^%webhttp(0,"port"),9080)
 D job(PORT)
 QUIT
 ;
job(PORT,TLSCONFIG,NOGBL,USERPASS,NOGZIP,CORSENAB,CORSHDRS,CORSMETH,CORSORG,CORSCRED,CORSMXAG) ; Convenience entry point
 I $L($G(USERPASS))&($G(USERPASS)'[":") W "USERPASS argument is invalid, must be in username:password format!" QUIT
 I $P($SY,",")=47 J start^%webreq(PORT,,$G(TLSCONFIG),$G(NOGBL),,$G(USERPASS),$G(NOGZIP),$G(CORSENAB),$G(CORSHDRS),$G(CORSMETH),$G(CORSORG),$G(CORSCRED),$G(CORSMXAG)):(IN="/dev/null":OUT="/dev/null":ERR="webreq.mje"):5  ; no in and out files please.
 E  J start^%webreq(PORT,"",$G(TLSCONFIG),$G(NOGBL),"",$G(USERPASS),$G(NOGZIP),$G(CORSENAB),$G(CORSHDRS),$G(CORSMETH),$G(CORSORG),$G(CORSCRED),$G(CORSMXAG)) ; Cache can't accept empty arguments. Change to empty strings.
 QUIT
 ;
start(TCPPORT,DEBUG,TLSCONFIG,NOGBL,TRACE,USERPASS,NOGZIP,CORSENAB,CORSHDRS,CORSMETH,CORSORG,CORSCRED,CORSMXAG) ; set up listening for connections
 ; I hope TCPPORT needs no explanations.
 ;
 ; DEBUG is so that we run our server in the foreground.
 ; You can place breakpoints at CHILD+1 or anywhere else.
 ; CTRL-C will always work
 ;
 S:'$G(NOGBL) ^%webhttp(0,"listener")="starting"
 ;
 I '$G(NOGBL),$D(^DD) ; This just opens the main mumps.dat file so it can appear in lsof
 ;
 S %WOS=$S($P($SY,",")=47:"GT.M",$P($SY,",")=50:"MV1",1:"CACHE") ; Get Mumps Virtual Machine
 ;
 I %WOS="GT.M",'$G(NOGBL),$G(TRACE) VIEW "TRACE":1:"^%wtrace"
 ;
 ; $ZINTERRUPT for GT.M/YottaDB
 I %WOS="GT.M" D
 . I $T(JOBEXAM^ZSY)]"" S $ZINT="I $$JOBEXAM^ZSY($ZPOS),$$JOBEXAM^%webreq($ZPOS)"
 . E  S $ZINT="I $$JOBEXAM^%webreq($ZPOS)"
 ;
 S TCPPORT=$G(TCPPORT,9080)
 ;
 ; Device ID
 I %WOS="CACHE" S TCPIO="|TCP|"_TCPPORT
 I %WOS="GT.M" S TCPIO="SCK$"_TCPPORT
 ;
 ; Open Code
 I %WOS="CACHE" O TCPIO:(:TCPPORT:"ACT"):15 E  U 0 W !,"error cannot open port "_TCPPORT Q
 I %WOS="GT.M" O TCPIO:(LISTEN=TCPPORT_":TCP":delim=$C(13,10):attach="server"):15:"socket" E  U 0 W !,"error cannot open port "_TCPPORT Q
 ;
 ; K. Now we are really really listening.
 S:'$G(NOGBL) ^%webhttp(0,"listener")="running"
 ;
 I %WOS="GT.M" U TCPIO:(CHSET="M")
 E  U TCPIO
 ;
 I %WOS="GT.M" W /LISTEN(5) ; Listen 5 deep - sets $KEY to "LISTENING|socket_handle|portnumber"
 N PARSOCK S PARSOCK=$P($KEY,"|",2)  ; Parent socket
 N CHILDSOCK  ; That will be set below; Child socket
 ;
 I $G(DEBUG) D DEBUG($G(TLSCONFIG))
 ;
LOOP ; wait for connection, spawn process to handle it. GOTO favorite.
 I ('$G(NOGBL)),$E(^%webhttp(0,"listener"),1,4)="stop" C TCPIO S ^%webhttp(0,"listener")="stopped" Q
 ;
 ; ---- CACHE CODE ----
 I %WOS="CACHE" D  G LOOP
 . R *X:10
 . E  QUIT  ; Loop back again when listening and nobody on the line
 . J CHILD($G(TLSCONFIG),$G(NOGBL),$G(TRACE),$G(USERPASS),$G(NOGZIP),$G(CORSENAB),$G(CORSHDRS),$G(CORSMETH),$G(CORSORG),$G(CORSCRED),$G(CORSMXAG)):(:4:TCPIO:TCPIO):10 ; Send off the device to another job for input and output.
 . i $ZA\8196#2=1 W *-2  ; job failed to clear bit
 ; ---- END CACHE CODE ----
 ;
 ; ----- GT.M CODE ----
 ; In GT.M $KEY is "CONNECT|socket_handle|portnumber" then "READ|socket_handle|portnumber"
 ; N GTMDONE S GTMDONE=0  ; To tell us if we should loop waiting or process HTTP requests ; don't need this anymore
 ;I %WOS="GT.M" D  G LOOP:'GTMDONE,CHILD:GTMDONE
 I %WOS="GT.M" D  G LOOP
 . ;
 . ; Wait until we have a connection (inifinte wait).
 . ; Stop if the listener asked us to stop.
 . FOR  W /WAIT(10) Q:$KEY]""  Q:$G(NOGBL)  Q:($E(^%webhttp(0,"listener"),1,4)="stop")
 . ;
 . ; We have to stop! When we quit, we go to loop, and we exit at LOOP+1
 . I '$G(NOGBL),$E(^%webhttp(0,"listener"),1,4)="stop" QUIT
 . ; 
 . ; At connection, job off the new child socket to be served away.
 . ; I $P($KEY,"|")="CONNECT" QUIT ; before 6.1
 . I $P($KEY,"|")="CONNECT" D  ; >=6.1
 . . S CHILDSOCK=$P($KEY,"|",2)
 . . U TCPIO:(detach=CHILDSOCK)
 . . N Q S Q=""""
 . . N ARG S ARG=Q_"SOCKET:"_CHILDSOCK_Q
 . . N J S J="CHILD($G(TLSCONFIG),$G(NOGBL),$G(TRACE),$G(USERPASS),$G(NOGZIP),$G(CORSENAB),$G(CORSHDRS),$G(CORSMETH),$G(CORSORG),$G(CORSCRED),$G(CORSMXAG)):(input="_ARG_":output="_ARG_")"
 . . J @J
 . ;
 . ; GT.M before 6.1:
 . ; Use the incoming socket; close the server, and restart it and goto CHILD
 . ; USE TCPIO:(SOCKET=$P($KEY,"|",2))
 . ; CLOSE TCPIO:(SOCKET="server")
 . ; JOB START^%webreq(TCPPORT):(IN="/dev/null":OUT="/dev/null":ERR="/dev/null"):5
 . ; SET GTMDONE=1  ; Will goto CHILD at the DO exist up above
 . ; ---- END GT.M CODE ----
 ;
 QUIT
 ;
DEBUG(TLSCONFIG) ; Debug continuation. We don't job off the request, rather run it now.
 ; Stop using Ctrl-C (duh!)
 N $ET S $ET="BREAK"
 K:'$G(NOGBL) ^%webhttp("log") ; Kill log so that we can see our errors when they happen.
 I %WOS="GT.M" U $I:(CENABLE:ioerror="T")
 I %WOS="CACHE" F  R *X:10 I  G CHILDDEBUG
 I %WOS="GT.M" F  W /WAIT(10) I $KEY]"" G CHILDDEBUG
 QUIT
 ;
JOBEXAM(%ZPOS) ; Interrupt framework for GT.M.
 N S S S=""
 F  S S=$O(^%webhttp("processlog",+$H,S)) Q:'S  K ^(S,$J)  ; **NAKED** ; delete old $ZINTs
 ZSHOW "*":^%webhttp("processlog",+$H,$P($H,",",2),$J)
 QUIT 1
 ;
GTMLNX  ;From Linux xinetd script; $P is the main stream
 S ^%webhttp(0,"listener")="starting"
 I $T(JOBEXAM^ZSY)]"" S $ZINT="I $$JOBEXAM^ZSY($ZPOS),$$JOBEXAM^%webreq($ZPOS)"
 E  S $ZINT="I $$JOBEXAM^%webreq($ZPOS)"
 X "U $P:(nowrap:nodelimiter:ioerror=""ETSOCK"")"
 S %="",@("%=$ZTRNLNM(""REMOTE_HOST"")") S:$L(%) IO("IP")=%
 G CHILD
 ;
 ; Child Handling Process ---------------------------------
 ;
 ; The following variables exist during the course of the request
 ; HTTPREQ contains the HTTP request, with subscripts as follow --
 ; HTTPREQ("method") contains GET, POST, PUT, HEAD, or DELETE
 ; HTTPREQ("path") contains the path of the request (part from server to ?)
 ; HTTPREQ("query") contains any query params (part after ?)
 ; HTTPREQ("header",name) contains a node for each header value
 ; HTTPREQ("body",n) contains as an array the body of the request
 ; HTTPREQ("location") stashes the location value for PUT, POST
 ; HTTPREQ("store") stashes the type of store (vpr or data)
 ;
 ; HTTPRSP contains the HTTP response (or name of global with the response)
 ; HTTPLOG indicates the logging level for this process
 ; HTTPERR non-zero if there is an error state
 ;
CHILD(TLSCONFIG,NOGBL,TRACE,USERPASS,NOGZIP,CORSENAB,CORSHDRS,CORSMETH,CORSORG,CORSCRED,CORSMXAG) ; handle HTTP requests on this connection
CHILDDEBUG ; [Internal] Debugging entry point
 S %WTCP=$GET(TCPIO,$PRINCIPAL) ; TCP Device
 S %WOS=$S($P($SY,",")=47:"GT.M",$P($SY,",")=50:"MV1",1:"CACHE") ; Get Mumps Virtual Machine
 ;
 I %WOS="GT.M",'$G(NOGBL),$G(TRACE) VIEW "TRACE":1:"^%wtrace" ; Tracing for Unit Test Coverage
 ;
 S:'$G(NOGBL) HTTPLOG=$G(^%webhttp(0,"logging"),0) ; HTTPLOG remains set throughout
 S:$G(NOGBL) HTTPLOG=0
 S HTTPLOG("DT")=+$H
 D INCRLOG ; set unique request id for log
 N $ET S $ET="G ETSOCK^%webreq"
 ;
TLS ; Turn on TLS?
 I TLSCONFIG]"" D
 . I %WOS="GT.M" W /TLS("server",1,TLSCONFIG)
 . I %WOS="CACHE" U %WTCP:(::"-M":/TLS=TLSCONFIG)
 N D,K,T
 ; put a break point here to debug TLS
 S D=$DEVICE,K=$KEY,T=$TEST
 ; U 0
 ; W !
 ; W "$DEVICE: "_D,!
 ; W "$KEY: "_K,!
 ; W "$TEST: "_T,!
 ; U %WTCP
 ;
NEXT ; begin next request
 K HTTPREQ,HTTPRSP,HTTPERR
 K:'$G(NOGBL) ^TMP($J),^TMP("HTTPERR",$J) ; TODO: change the namespace for the error global
 ;
WAIT ; wait for request on this connection
 I '$G(NOGBL),$E($G(^%webhttp(0,"listener")),1,4)="stop" C %WTCP Q
 X:%WOS="CACHE" "U %WTCP:(::""CT"")" ;VEN/SMH - Cache Only line; Terminators are $C(10,13)
 X:%WOS="GT.M" "U %WTCP:(delim=$C(13,10):chset=""M"")" ; VEN/SMH - GT.M Delimiters
 R TCPX:10 I '$T G ETDC
 I '$L(TCPX) G ETDC
 ;
 ; -- got a request and have the first line
 I HTTPLOG D LOGRAW(TCPX),LOGHDR(TCPX)
 S HTTPREQ("method")=$P(TCPX," ")
 S HTTPREQ("path")=$P($P(TCPX," ",2),"?")
 S HTTPREQ("query")=$P($P(TCPX," ",2),"?",2,999)
 ; TODO: time out connection after N minutes of wait
 ; TODO: check format of TCPX and raise error if not correct
 I $E($P(TCPX," ",3),1,4)'="HTTP" G NEXT
 ;
 ; -- read the rest of the lines in the header
 F  S TCPX=$$RDCRLF() Q:'$L(TCPX)  D ADDHEAD(TCPX)
 ;
 ; -- Handle Contiuation Request - VEN/SMH
 I $G(HTTPREQ("header","expect"))="100-continue" D:HTTPLOG LOGCN W "HTTP/1.1 100 Continue",$C(13,10,13,10),!
 ;
 ; -- decide how to read body, if any
 X:%WOS="CACHE" "U %WTCP:(::""S"")" ; Stream mode
 X:%WOS="GT.M" "U %WTCP:(nodelim)" ; VEN/SMH - GT.M Delimiters
 I $$LOW^%webutils($G(HTTPREQ("header","transfer-encoding")))="chunked" D
 . D RDCHNKS ; TODO: handle chunked input
 . I HTTPLOG>2 ; log array of chunks
 I $G(HTTPREQ("header","content-length"))>0 D
 . D RDLEN(HTTPREQ("header","content-length"),99)
 . I HTTPLOG>2 D LOGBODY
 ;
 N CORS
 I $G(NOGBL) D
 . S CORS("enabled")=$G(CORSENAB)
 . S CORS("credentials")=$G(CORSCRED)
 . S CORS("method")=$G(CORSMETH)
 . S CORS("header")=$G(CORSHDRS)
 . S CORS("origin")=$G(CORSORG)
 . S CORS("maxAge")=$G(CORSMXAG)
 E  I $D(^%webhttp(0,"cors")) M CORS=^%webhttp(0,"cors")
 ;
 ;
 ; -- build response (map path to routine & call, otherwise 404)
 S $ETRAP="G ETCODE^%webreq"
 S HTTPERR=0
 D RESPOND^%webrsp
 S $ETRAP="G ETSOCK^%webreq"
 ; TODO: restore HTTPLOG if necessary
 ;
 ; -- write out the response (error if HTTPERR>0)
 X:%WOS="CACHE" "U %WTCP:(::""S"")" ; Stream mode
 X:%WOS="GT.M" "U %WTCP:(nodelim)" ; VEN/SMH - GT.M Delimiters
 I $G(HTTPERR) D RSPERROR^%webrsp ; switch to error response
 I HTTPLOG>2 D LOGRSP
 D SENDATA^%webrsp
 ;
 ; -- exit on Connection: Close (or if tracing is on so that we can get our trace results)
 I $$LOW^%webutils($G(HTTPREQ("header","connection")))="close"!$G(TRACE) D  HALT
 . K:'$G(NOGBL) ^TMP($J),^TMP("HTTPERR",$J)
 . C %WTCP
 ;
 ; -- otherwise get ready for the next request
 ;
 ; Remove DUZ from ST and Logout if we logged into VistA
 I $G(DUZ) D
 . D LOGOUT^XUSRB
 . K DUZ
 ;
 I %WOS="GT.M"&$G(HTTPLOG) ZGOTO 0:NEXT^%webreq ; unlink all routines; only for debug mode
 G NEXT
 ;
RDCRLF() ; read a header line
 ; fixes a problem where the read would terminate before CRLF
 ; (on a packet boundary or when 1024 characters had been read)
 N X,LINE,RETRY
 S LINE=""
 F RETRY=1:1 R X:1 D:HTTPLOG LOGRAW(X) S LINE=LINE_X Q:$A($ZB)=13  Q:RETRY>10
 Q LINE
 ;
RDCHNKS ; read body in chunks
 Q  ; still need to implement
 ;
RDLEN(REMAIN,TIMEOUT) ; read L bytes with timeout T
 N X,LINE,LENGTH
 S LINE=0
RDLOOP ;
 ; read until L bytes collected
 ; quit with what we have if read times out
 S LENGTH=REMAIN I LENGTH>4000 S LENGTH=4000
 R X#LENGTH:TIMEOUT
 I '$T D:HTTPLOG>1 LOGRAW("timeout:"_X) S LINE=LINE+1,HTTPREQ("body",LINE)=X Q
 I HTTPLOG>1 D LOGRAW(X)
 S REMAIN=REMAIN-$L(X),LINE=LINE+1,HTTPREQ("body",LINE)=X
 G:REMAIN RDLOOP
 Q
 ;
ADDHEAD(LINE) ; add header name and header value
 ; expects HTTPREQ to be defined
 D:HTTPLOG LOGHDR(LINE)
 N NAME,VALUE
 S NAME=$$LOW^%webutils($$LTRIM^%webutils($P(LINE,":")))
 S VALUE=$$LTRIM^%webutils($P(LINE,":",2,99))
 I LINE'[":" S NAME="",VALUE=LINE
 I '$L(NAME) S NAME=$G(HTTPREQ("header")) ; grab the last name used
 I '$L(NAME) Q  ; no header name so just ignore this line
 I $D(HTTPREQ("header",NAME)) D
 . S HTTPREQ("header",NAME)=HTTPREQ("header",NAME)_","_VALUE
 E  D
 . S HTTPREQ("header",NAME)=VALUE,HTTPREQ("header")=NAME
 Q
 ;
ETSOCK ; error trap when handling socket (i.e., client closes connection)
 D LOGERR
 C %WTCP
 HALT  ; exit because connection has been closed
 ;
ETCODE ; error trap when calling out to routines
 S $ETRAP="G ETBAIL^%webreq"
 I $TLEVEL TROLLBACK ; abandon any transactions
 L                   ; release any locks
 i $d(%webcrash2) s $ec=",U-test-error-trap,"
 ; Set the error information and write it as the HTTP response.
 I $D(%WNULL) C %WNULL
 U %WTCP
 N ISGTM S ISGTM=$P($SYSTEM,",")=47
 N ERRTXT S ERRTXT=$S(ISGTM:$ZSTATUS,1:$ZERROR_"  ($ECODE:"_$ECODE_")")
 N ERRARR
 S ERRARR("message")=ERRTXT
 S ERRARR("reason")=$ECODE
 S ERRARR("place")=$STACK($STACK(-1),"PLACE")
 S ERRARR("mcode")=$STACK($STACK(-1),"MCODE")
 S ERRARR("logID")=HTTPLOG("ID")
 D:'$G(NOGBL) SETERROR^%webutils(501,,.ERRARR) ; sets HTTPERR
 D LOGERR
 D:'$G(NOGBL) RSPERROR^%webrsp  ; switch to error response
 D SENDATA^%webrsp
 ; This next line will 'unwind' the stack and got back to listening
 ; for the next HTTP request (goto NEXT).
 S $ETRAP="Q:$ESTACK&$QUIT 0 Q:$ESTACK  S $ECODE="""" G NEXT",$ECODE=",U-UNWIND,"
 Q
ETDC ; error trap for client disconnect ; not a true M trap
 D:HTTPLOG LOGDC
 K:'$G(NOGBL) ^TMP($J),^TMP("HTTPERR",$J)
 C $P
 HALT ; Stop process
 ;
ETBAIL ; error trap of error traps
 U %WTCP
 W "HTTP/1.1 500 Internal Server Error",$C(13,10),$C(13,10),!
 K:'$G(NOGBL) ^TMP($J),^TMP("HTTPERR",$J)
 C %WTCP
 HALT  ; exit because we can't recover
 ;
INCRLOG ; get unique log id for each request
 N DT,ID
 S DT=HTTPLOG("DT")
 I '$G(NOGBL) D
 . L +^%webhttp("log",DT):2 E  S HTTPLOG("ID")=99999 Q  ; get unique logging session
 . S ID=$G(^%webhttp("log",DT),0)+1
 . S ^%webhttp("log",DT)=ID
 . L -^%webhttp("log",DT)
 E  S ID=99999
 S HTTPLOG("ID")=ID
 Q:'HTTPLOG
 S:'$G(NOGBL) ^%webhttp("log",DT,$J,ID)=$$HTE^%webutils($H)_"  $J:"_$J_"  $P:"_%WTCP_"  $STACK:"_$STACK
 Q
LOGRAW(X) ; log raw lines read in
 N DT,ID,LN
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 I $G(NOGBL) QUIT
 S LN=$G(^%webhttp("log",DT,$J,ID,"raw"),0)+1
 S ^%webhttp("log",DT,$J,ID,"raw")=LN
 S ^%webhttp("log",DT,$J,ID,"raw",LN)=X
 S ^%webhttp("log",DT,$J,ID,"raw",LN,"ZB")=$A($ZB)
 Q
LOGHDR(X) ; log header lines read in
 N DT,ID,LN
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 I $G(NOGBL) QUIT
 S LN=$G(^%webhttp("log",DT,$J,ID,"req","header"),0)+1
 S ^%webhttp("log",DT,$J,ID,"req","header")=LN
 S ^%webhttp("log",DT,$J,ID,"req","header",LN)=X
 Q
LOGBODY ; log the request body
 Q:'$D(HTTPREQ("body"))
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 I $G(NOGBL) QUIT
 M ^%webhttp("log",DT,$J,ID,"req","body")=HTTPREQ("body")
 Q
LOGRSP ; log the response before sending
 I '$L($G(HTTPRSP))&'$O(HTTPRSP("")) QUIT  ; Q:'$D(@HTTPRSP) VEN/SMH - Response may be scalar
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 I $G(NOGBL) QUIT
 I $E($G(HTTPRSP))="^" M ^%webhttp("log",DT,$J,ID,"response")=@HTTPRSP
 E  M ^%webhttp("log",DT,$J,ID,"response")=HTTPRSP
 Q
LOGCN ; log continue
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 I $G(NOGBL) QUIT
 S ^%webhttp("log",DT,$J,ID,"continue")="HTTP/1.1 100 Continue"
 QUIT
LOGDC ; log client disconnection; VEN/SMH
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 I $G(NOGBL) QUIT
 S ^%webhttp("log",DT,$J,ID,"disconnect")=$$HTE^%webutils($H)
 QUIT
 ;
LOGERR ; log error information
 Q:$G(NOGBL)
 N %D,%I
 S %D=HTTPLOG("DT"),%I=HTTPLOG("ID")
 N ISGTM S ISGTM=$P($SYSTEM,",")=47
 S ^%webhttp("log",%D,$J,%I,"error")=$S(ISGTM:$ZSTATUS,1:$ZERROR_"  ($ECODE:"_$ECODE_")")
 N %LVL,%TOP,%N
 S %TOP=$STACK(-1)-1,%N=0
 F %LVL=0:1:%TOP S %N=%N+1,^%webhttp("log",%D,$J,%I,"error","stack",%N)=$STACK(%LVL,"PLACE")_":"_$STACK(%LVL,"MCODE")
 N %X,%Y
 S %X="^%webhttp(""log"",%D,$J,%I,""error"",""symbols"","
 ; Works on GT.M and Cache to capture ST.
 S %Y="%" F  M:$D(@%Y) @(%X_"%Y)="_%Y) S %Y=$O(@%Y) Q:%Y=""
 I ISGTM ZSHOW "D":^%webhttp("log",%D,$J,%I,"error","devices")
 ; If VistA Error Trap exists, log the error there too.
 I $T(+0^%ZTER)'="" D ^%ZTER
 Q
 ;
stop ; tell the listener to stop running
 S ^%webhttp(0,"listener")="stopped"
 Q
 ;
 ; Portions of this code are public domain, but it was extensively modified
 ; Copyright 2013-2019 Sam Habiel
 ; Copyright 2018-2019 Christopher Edwards
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%webjsonEncode
%webjsonEncode ;SLC/KCM -- Encode JSON;2019-11-14  9:06 AM
 ;
encode(VVROOT,VVJSON,VVERR) G DIRECT
ENCODE(VVROOT,VVJSON,VVERR) ; VVROOT (M structure) --> VVJSON (array of strings)
 ;
DIRECT ; TAG for use by ENCODE^%webjson
 ;
 ; Examples:  D ENCODE^%webjson("^GLO(99,2)","^TMP($J)")
 ;            D ENCODE^%webjson("LOCALVAR","MYJSON","LOCALERR")
 ;
 ; VVROOT: closed array reference for M representation of object
 ; VVJSON: destination variable for the string array formatted as JSON
 ;  VVERR: contains error messages, defaults to ^TMP("%webjsonerr",$J)
 ;
 S VVERR=$G(VVERR,"^TMP(""%webjsonerr"",$J)")
 I '$L($G(VVROOT)) ; set error info
 I '$L($G(VVJSON)) ; set error info
 N VVLINE,VVMAX,VVSUB,VVERRORS
 ;
 ; V4W/DLW - Changed VVMAX from 4000 (just under the 4096 string size limit)
 ; to 100. With large data arrays, the JSON encoder could exhaust system
 ; memory, which required a switch to globals to fix. However, 4000 as a
 ; limit slowed the encoder down quite a bit, when using globals.
 ; With the change to VVMAX, the following Unit Tests required changes:
 ; PURENUM^%webjsonDecodeTest,
 ; ESTRING^%webjsonDecodeTest, BASIC^%webjsonEncodeTest, VALS^%webjsonEncodeTest, LONG^%webjsonEncodeTest,
 ; PRE^%webjsonEncodeTest, WP^%webjsonEncodeTest, EXAMPLE^%webjsonEncodeTest
 S VVLINE=1,VVMAX=100,VVERRORS=0 ; limit document lines to 100 characters
 S @VVJSON@(VVLINE)=""
 ; If first subscript is numeric, run array code and done
 ; https://groups.google.com/d/msg/comp.lang.mumps/RcogxQKtkJw/lN7AzAVzBAAJ
 S VVSUB=$O(@VVROOT@(""))
 I +VVSUB=VVSUB D
 . D SERARY(VVROOT)
 E  D
 . D SEROBJ(VVROOT)
 Q
 ;
SEROBJ(VVROOT) ; Serialize into a JSON object
 N VVFIRST,VVSUB,VVNXT
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"{"
 S VVFIRST=1
 S VVSUB="" F  S VVSUB=$O(@VVROOT@(VVSUB)) Q:VVSUB=""  D
 . S:'VVFIRST @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"," S VVFIRST=0
 . ; get the name part
 . D SERNAME(VVSUB)
 . ; if this is a value, serialize it
 . I $$ISVALUE(VVROOT,VVSUB) D SERVAL(VVROOT,VVSUB) Q
 . ; otherwise navigate to the next child object or array
 . I $D(@VVROOT@(VVSUB))=10 S VVNXT=$O(@VVROOT@(VVSUB,"")) D  Q
 . . ; Need to check if numeric representation matches string representation to decide if it is an array
 . . I +VVNXT=VVNXT D SERARY($NA(@VVROOT@(VVSUB))) I 1
 . . E  D SEROBJ($NA(@VVROOT@(VVSUB)))
 . D ERRX("SOB",VVSUB)  ; should quit loop before here
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"}"
 Q
SERARY(VVROOT) ; Serialize into a JSON array
 N VVFIRST,VVI,VVNXT
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"["
 S VVFIRST=1
 S VVI=0 F  S VVI=$O(@VVROOT@(VVI)) Q:'VVI  D
 . S:'VVFIRST @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"," S VVFIRST=0
 . I $$ISVALUE(VVROOT,VVI) D SERVAL(VVROOT,VVI) Q  ; write value
 . I $D(@VVROOT@(VVI))=10 S VVNXT=$O(@VVROOT@(VVI,"")) D  Q
 . . ; Need to check if numeric representation matches string representation to decide if it is an array
 . . I +VVNXT=VVNXT D SERARY($NA(@VVROOT@(VVI))) I 1
 . . E  D SEROBJ($NA(@VVROOT@(VVI)))
 . D ERRX("SAR",VVI)  ; should quit loop before here
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"]"
 Q
SERNAME(VVSUB) ; Serialize the object name into JSON string
 I $E(VVSUB)="""" S VVSUB=$E(VVSUB,2,$L(VVSUB)) ; quote indicates numeric label
 I ($L(VVSUB)+$L(@VVJSON@(VVLINE)))>VVMAX S VVLINE=VVLINE+1,@VVJSON@(VVLINE)=""
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_""""_$$ESC(VVSUB)_""""_":"
 Q
SERVAL(VVROOT,VVSUB) ; Serialize X into appropriate JSON representation
 N VVX,VVI,VVDONE
 ; if the node is already in JSON format, just add it
 I $D(@VVROOT@(VVSUB,":")) D  QUIT  ; <-- jump out here if preformatted
 . S VVX=$G(@VVROOT@(VVSUB,":")) D:$L(VVX) CONCAT
 . S VVI=0 F  S VVI=$O(@VVROOT@(VVSUB,":",VVI)) Q:'VVI  S VVX=@VVROOT@(VVSUB,":",VVI) D CONCAT
 ;
 S VVX=$G(@VVROOT@(VVSUB)),VVDONE=0
 ; handle the numeric, boolean, and null types
 I $D(@VVROOT@(VVSUB,"\n")) S:$L(@VVROOT@(VVSUB,"\n")) VVX=@VVROOT@(VVSUB,"\n") D CONCAT QUIT  ; when +X'=X
 I '$D(@VVROOT@(VVSUB,"\s")),$L(VVX) D  QUIT:VVDONE
 . I VVX']]$C(1) S VVX=$$JNUM(VVX) D CONCAT S VVDONE=1 QUIT
 . I VVX="true"!(VVX="false")!(VVX="null") D CONCAT S VVDONE=1 QUIT
 ; otherwise treat it as a string type
 S VVX=""""_$$ESC(VVX) ; open quote
 D CONCAT
 I $D(@VVROOT@(VVSUB,"\")) D  ; handle continuation nodes
 . S VVI=0 F  S VVI=$O(@VVROOT@(VVSUB,"\",VVI)) Q:'VVI   D
 . . S VVX=$$ESC(@VVROOT@(VVSUB,"\",VVI))
 . . D CONCAT
 S VVX="""" D CONCAT    ; close quote
 Q
CONCAT ; come here to concatenate to JSON string
 I ($L(VVX)+$L(@VVJSON@(VVLINE)))>VVMAX S VVLINE=VVLINE+1,@VVJSON@(VVLINE)=""
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_VVX
 Q
ISVALUE(VVROOT,VVSUB) ; Return true if this is a value node
 I $D(@VVROOT@(VVSUB))#2 Q 1
 N VVX S VVX=$O(@VVROOT@(VVSUB,""))
 Q:VVX="\" 1  ; word processing continuation node
 Q:VVX=":" 1  ; pre-formatted JSON node
 Q 0
 ;
NUMERIC(X) ; Return true if the numeric
 I $L(X)>18 Q 0        ; string (too long for numeric)
 I X=0 Q 1             ; numeric (value is zero)
 I +X=0 Q 0            ; string
 I $E(X,1)="." Q 0     ; not a JSON number (although numeric in M)
 I $E(X,1,2)="-." Q 0  ; not a JSON number
 I +X=X Q 1            ; numeric
 I X?1"0."1.n Q 1      ; positive fraction
 I X?1"-0."1.N Q 1     ; negative fraction
 S X=$TR(X,"e","E")
 I X?.1"-"1.N.1".".N1"E".1"+"1.N Q 1  ; {-}99{.99}E{+}99
 I X?.1"-"1.N.1".".N1"E-"1.N Q 1      ; {-}99{.99}E-99
 Q 0
 ;
ESC(X) ; Escape string for JSON
 N Y,I,PAIR,FROM,TO
 S Y=X
 F PAIR="\\","""""","//",$C(8,98),$C(12,102),$C(10,110),$C(13,114),$C(9,116) D
 . S FROM=$E(PAIR),TO=$E(PAIR,2)
 . S X=Y,Y=$P(X,FROM) F I=2:1:$L(X,FROM) S Y=Y_"\"_TO_$P(X,FROM,I)
 I Y?.E1.C.E S X=Y,Y="" F I=1:1:$L(X) S FROM=$A(X,I) D
 . ; skip NUL character, otherwise encode ctrl-char
 . I FROM<32 Q:FROM=0  S Y=Y_$$UCODE(FROM) Q
 . I FROM>126,(FROM<160) S Y=Y_$$UCODE(FROM) Q
 . S Y=Y_$E(X,I)
 Q Y
 ;
JNUM(N) ; Return JSON representation of a number
 I N'<1 Q N
 I N'>-1 Q N
 I N>0 Q "0"_N
 I N<0 Q "-0"_$P(N,"-",2,9)
 Q N
 ;
UCODE(C) ; Return \u00nn representation of decimal character value
 N H S H="0000"_$$CNV^%webutils(C,16)
 Q "\u"_$E(H,$L(H)-3,$L(H))
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 D ERRX^%webjson(ID,$G(VAL))
 Q
 ;
 ; Portions of this code are public domain, but it was extensively modified
 ; Copyright 2016 Accenture Federal Services
 ; Copyright 2013-2019 Sam Habiel
 ; Copyright 2019 Christopher Edwards
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%webjsonDecode
%webjsonDecode ;SLC/KCM -- Decode JSON;2019-11-14  9:06 AM
 ;
decode(VVJSON,VVROOT,VVERR) G DIRECT
DECODE(VVJSON,VVROOT,VVERR) ; Set JSON object into closed array ref VVROOT
 ;
DIRECT ; TAG for use by DECODE^%webjson
 ;
 ; Examples: D DECODE^%webjson("MYJSON","LOCALVAR","LOCALERR")
 ;           D DECODE^%webjson("^MYJSON(1)","^GLO(99)","^TMP($J)")
 ;
 ; VVJSON: string/array containing serialized JSON object
 ; VVROOT: closed array reference for M representation of object
 ;  VVERR: contains error messages, defaults to ^TMP("%webjsonerr",$J)
 ;
 ;   VVIDX: points to next character in JSON string to process
 ; VVSTACK: manages stack of subscripts
 ;  VVPROP: true if next string is property name, otherwise treat as value
 ;
 ; V4W/DLW - Changed VVMAX from 4000 to 100, same as in the encoder
 ; With the change to VVMAX, the following Unit Tests required changes:
 ; SPLITA^%webjsonDecodeTest, SPLITB^%webjsonDecodeTest, LONG^%webjsonDecodeTest, MAXNUM^%webjsonDecodeTest
 N VVMAX S VVMAX=100 ; limit document lines to 100 characters
 S VVERR=$G(VVERR,"^TMP(""%webjsonerr"",$J)")
 ; If a simple string is passed in, move it to an temp array (VVINPUT)
 ; so that the processing is consistently on an array.
 I $D(@VVJSON)=1 N VVINPUT S VVINPUT(1)=@VVJSON,VVJSON="VVINPUT"
 S VVROOT=$NA(@VVROOT@("Z")),VVROOT=$E(VVROOT,1,$L(VVROOT)-4) ; make open array ref
 N VVLINE,VVIDX,VVSTACK,VVPROP,VVTYPE,VVERRORS
 S VVLINE=$O(@VVJSON@("")),VVIDX=1,VVSTACK=0,VVPROP=0,VVERRORS=0
 F  S VVTYPE=$$NXTKN() Q:VVTYPE=""  D  I VVERRORS Q
 . I VVTYPE="{" S VVSTACK=VVSTACK+1,VVSTACK(VVSTACK)="",VVPROP=1 D:VVSTACK>64 ERRX("STL{") Q
 . I VVTYPE="}" D  QUIT
 . . I VVSTACK'>0 D ERRX("SUF}") Q  ; Extra Brace. Nothing to pop.
 . . I VVSTACK(VVSTACK)?1n.n,VVSTACK(VVSTACK) D ERRX("OBM") Q  ; Numeric and true only
 . . S VVSTACK=VVSTACK-1
 . I VVTYPE="[" S VVSTACK=VVSTACK+1,VVSTACK(VVSTACK)=1 D:VVSTACK>64 ERRX("STL[") Q
 . I VVTYPE="]" D:'VVSTACK(VVSTACK) ERRX("ARM") S VVSTACK=VVSTACK-1 D:VVSTACK<0 ERRX("SUF]") Q
 . ;
 . ; At this point, we should be in a brace or a bracket (indicated by VVSTACK>0)
 . ; If not we have an error condition
 . I VVSTACK'>0 D ERRX("TRL",VVTYPE) Q
 . ;
 . I VVTYPE="," D  Q
 . . I +VVSTACK(VVSTACK)=VVSTACK(VVSTACK),VVSTACK(VVSTACK) S VVSTACK(VVSTACK)=VVSTACK(VVSTACK)+1  ; VEN/SMH - next in array
 . . E  S VVPROP=1                                   ; or next property name
 . I VVTYPE=":" S VVPROP=0 D:'$L($G(VVSTACK(VVSTACK))) ERRX("MPN") Q
 . I VVTYPE="""" D  Q
 . . I VVPROP S VVSTACK(VVSTACK)=$$UES($$NAMPARS(),1) I 1
 . . E  D ADDSTR
 . S VVTYPE=$TR(VVTYPE,"TFN","tfn")
 . I VVTYPE="t" D SETBOOL("t") Q
 . I VVTYPE="f" D SETBOOL("f") Q
 . I VVTYPE="n" D SETBOOL("n") Q
 . I "0123456789+-.eE"[VVTYPE D SETNUM(VVTYPE) Q  ;S @$$CURNODE()=$$NUMPARS(VVTYPE) Q
 . D ERRX("TKN",VVTYPE)
 I VVSTACK'=0 D ERRX("SCT",VVSTACK)
 Q
NXTKN() ; Move the pointers to the beginning of the next token
 N VVDONE,VVEOF,VVTOKEN
 S VVDONE=0,VVEOF=0 F  D  Q:VVDONE!VVEOF  ; eat spaces & new lines until next visible char
 . I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=$O(@VVJSON@(VVLINE)),VVIDX=1 I 'VVLINE S VVEOF=1 Q
 . I $A(@VVJSON@(VVLINE),VVIDX)>32 S VVDONE=1 Q
 . S VVIDX=VVIDX+1
 Q:VVEOF ""  ; we're at the end of input
 S VVTOKEN=$E(@VVJSON@(VVLINE),VVIDX),VVIDX=VVIDX+1
 Q VVTOKEN
 ;
ADDSTR ; Add string value to current node, escaping text along the way
 ; Expects VVLINE,VVIDX to reference that starting point of the index
 ; TODO: add a mechanism to specify names that should not be escaped
 ;       just store as ":")= and ":",n)=
 ;
 ; Happy path -- we find the end quote in the same line
 N VVEND,VVX
 S VVEND=$F(@VVJSON@(VVLINE),"""",VVIDX)
 I VVEND,($E(@VVJSON@(VVLINE),VVEND-2)'="\") D SETSTR  QUIT  ;normal
 I VVEND,$$ISCLOSEQ(VVLINE) D SETSTR QUIT  ;close quote preceded by escaped \
 ;
 ; Less happy path -- first quote wasn't close quote
 N VVDONE,VVTLINE
 S VVDONE=0,VVTLINE=VVLINE ; VVTLINE for temporary increment of VVLINE
 F  D  Q:VVDONE  Q:VVERRORS
 . ;if no quote on current line advance line, scan again
 . I 'VVEND S VVTLINE=VVTLINE+1,VVEND=1 I '$D(@VVJSON@(VVTLINE)) D ERRX("EIQ") Q
 . S VVEND=$F(@VVJSON@(VVTLINE),"""",VVEND)
 . Q:'VVEND  ; continue on to next line if no quote found on this one
 . I (VVEND>2),($E(@VVJSON@(VVTLINE),VVEND-2)'="\") S VVDONE=1 Q  ; found quote position
 . S VVDONE=$$ISCLOSEQ(VVTLINE) ; see if this is an escaped quote or closing quote
 Q:VVERRORS
 ; unescape from VVIDX to VVEND, using \-extension nodes as necessary
 D UESEXT
 ; now we need to move VVLINE and VVIDX to next parsing point
 S VVLINE=VVTLINE,VVIDX=VVEND
 Q
SETSTR ; Set simple string value from within same line
 ; expects VVJSON, VVLINE, VVINX, VVEND
 N VVX
 S VVX=$E(@VVJSON@(VVLINE),VVIDX,VVEND-2),VVIDX=VVEND
 S @$$CURNODE()=$$UES(VVX)
 ; "\s" node indicates value is really a string in case value
 ;      collates as numeric or equals boolean keywords
 I VVX']]$C(1) S @$$CURNODE()@("\s")=""
 I VVX="true"!(VVX="false")!(VVX="null") S @$$CURNODE()@("\s")=""
 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1
 Q
UESEXT ; unescape from VVLINE,VVIDX to VVTLINE,VVEND & extend (\) if necessary
 ; expects VVLINE,VVIDX,VVTLINE,VVEND
 N VVI,VVY,VVSTART,VVSTOP,VVDONE,VVBUF,VVNODE,VVMORE,VVTO
 S VVNODE=$$CURNODE(),VVBUF="",VVMORE=0,VVSTOP=VVEND-2
 S VVI=VVIDX,VVY=VVLINE,VVDONE=0
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVSTART=VVI,VVI=$F(@VVJSON@(VVY),"\",VVI)
 . ; if we are on the last line, don't extract past VVSTOP
 . I (VVY=VVTLINE) S VVTO=$S('VVI:VVSTOP,VVI>VVSTOP:VVSTOP,1:VVI-2) I 1
 . E  S VVTO=$S('VVI:99999,1:VVI-2)
 . D ADDBUF($E(@VVJSON@(VVY),VVSTART,VVTO))
 . I (VVY'<VVTLINE),(('VVI)!(VVI>VVSTOP)) S VVDONE=1 QUIT  ; now past close quote
 . I 'VVI S VVY=VVY+1,VVI=1 QUIT  ; nothing escaped, go to next line
 . I VVI>$L(@VVJSON@(VVY)) S VVY=VVY+1,VVI=1 I '$D(@VVJSON@(VVY)) D ERRX("EIU")
 . N VVTGT S VVTGT=$E(@VVJSON@(VVY),VVI)
 . I VVTGT="u" D  I 1
 . . N VVTGTC S VVTGTC=$E(@VVJSON@(VVY),VVI+1,VVI+4),VVI=VVI+4
 . . I $L(VVTGTC)<4 S VVY=VVY+1,VVI=4-$L(VVTGTC),VVTGTC=VVTGTC_$E(@VVJSON@(VVY),1,VVI)
 . . D ADDBUF($C($$DEC^%webutils(VVTGTC,16)))
 . E  D ADDBUF($$REALCHAR(VVTGT))
 . S VVI=VVI+1
 . I (VVY'<VVTLINE),(VVI>VVSTOP) S VVDONE=1 ; VVI incremented past stop
 Q:VVERRORS
 D SAVEBUF
 Q
ADDBUF(VVX) ; add buffer of characters to destination
 ; expects VVBUF,VVMAX,VVNODE,VVMORE to be defined
 ; used directly by ADDSTR
 I $L(VVX)+$L(VVBUF)>VVMAX D SAVEBUF
 S VVBUF=VVBUF_VVX
 Q
SAVEBUF ; write out buffer to destination
 ; expects VVBUF,VVMAX,VVNODE,VVMORE to be defined
 ; used directly by ADDSTR,ADDBUF
 I VVMORE S @VVNODE@("\",VVMORE)=VVBUF
 I 'VVMORE S @VVNODE=VVBUF I $L(VVBUF)<19,+$E(VVBUF,1,18) S @VVNODE@("\s")=""
 S VVMORE=VVMORE+1,VVBUF=""
 Q
ISCLOSEQ(VVBLINE) ; return true if this is a closing, rather than escaped, quote
 ; expects
 ;   VVJSON: lines of the JSON encoded string
 ;    VVIDX: points to 1st character of the segment
 ;   VVLINE: points to the line in which the segment starts
 ;    VVEND: points to 1st character after the " (may be past the end of the line)
 ; used directly by ADDSTR
 N VVBS,VVBIDX,VVBDONE
 S VVBS=0,VVBIDX=VVEND-2,VVBDONE=0 ; VVBIDX starts at 1st character before quote
 ; count the backslashes preceding the quote (odd number means the quote was escaped)
 F  D  Q:VVBDONE!VVERRORS
 . I VVBIDX<1 D  Q  ; when VVBIDX<1 go back a line
 . . S VVBLINE=VVBLINE-1 I VVBLINE<VVLINE D ERRX("RSB") Q
 . . S VVBIDX=$L(@VVJSON@(VVBLINE))
 . I $E(@VVJSON@(VVBLINE),VVBIDX)'="\" S VVBDONE=1 Q
 . S VVBS=VVBS+1,VVBIDX=VVBIDX-1
 Q VVBS#2=0  ; VVBS is even if this is a close quote
 ;
NAMPARS() ; Return parsed name, advancing index past the close quote
 N VVEND,VVDONE,VVNAME,VVSTART
 S VVDONE=0,VVNAME="",VVSTART=VVIDX
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVEND=$F(@VVJSON@(VVLINE),"""",VVIDX)
 . I $E(@VVJSON@(VVLINE),VVEND-2)="\" S VVIDX=VVEND Q
 . I VVEND S VVNAME=VVNAME_$E(@VVJSON@(VVLINE),VVSTART,VVEND-2),VVIDX=VVEND,VVDONE=1
 . I 'VVEND S VVNAME=VVNAME_$E(@VVJSON@(VVLINE),VVSTART,$L(@VVJSON@(VVLINE)))
 . I 'VVEND!(VVEND>$L(@VVJSON@(VVLINE))) S VVLINE=VVLINE+1,(VVIDX,VVSTART)=1 I '$D(@VVJSON@(VVLINE)) D ERRX("ORN")
 ; prepend quote if label collates as numeric -- assumes no quotes in label
 I VVNAME']]$C(1) S VVNAME=""""""_VVNAME
 Q VVNAME
 ;
SETNUM(VVDIGIT) ; Set numeric along with any necessary modifier
 N VVX
 S VVX=$$NUMPARS(VVDIGIT)
 S @$$CURNODE()=$S(VVX["e":+$TR(VVX,"e","E"),1:+VVX)
 ; if numeric is exponent, "0.nnn" or "-0.nnn" store original string
 I +VVX'=VVX S @$$CURNODE()@("\n")=VVX
 Q
NUMPARS(VVDIGIT) ; Return parsed number, advancing index past end of number
 ; VVIDX intially references the second digit
 N VVDONE,VVNUM
 S VVDONE=0,VVNUM=VVDIGIT
 F  D  Q:VVDONE  Q:VVERRORS
 . I '("0123456789+-.eE"[$E(@VVJSON@(VVLINE),VVIDX)) S VVDONE=1 Q
 . S VVNUM=VVNUM_$E(@VVJSON@(VVLINE),VVIDX)
 . S VVIDX=VVIDX+1 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1 I '$D(@VVJSON@(VVLINE)) D ERRX("OR#")
 Q VVNUM
 ;
SETBOOL(VVLTR) ; Parse and set boolean value, advancing index past end of value
 N VVDONE,VVBOOL,VVX
 S VVDONE=0,VVBOOL=VVLTR
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVX=$TR($E(@VVJSON@(VVLINE),VVIDX),"TRUEFALSN","truefalsn")
 . I '("truefalsn"[VVX) S VVDONE=1 Q
 . S VVBOOL=VVBOOL_VVX
 . S VVIDX=VVIDX+1 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1 I '$D(@VVJSON@(VVLINE)) D ERRX("ORB")
 I VVLTR="t",(VVBOOL'="true") D ERRX("EXT",VVTYPE)
 I VVLTR="f",(VVBOOL'="false") D ERRX("EXF",VVTYPE)
 I VVLTR="n",(VVBOOL'="null") D ERRX("EXN",VVTYPE)
 S @$$CURNODE()=VVBOOL
 Q
 ;
OSETBOOL(VVX) ; set a value and increment VVIDX
 S @$$CURNODE()=VVX
 S VVIDX=VVIDX+$L(VVX)-1
 N VVDIFF S VVDIFF=VVIDX-$L(@VVJSON@(VVLINE))  ; in case VVIDX moves to next line
 I VVDIFF>0 S VVLINE=VVLINE+1,VVIDX=VVDIFF I '$D(@VVJSON@(VVLINE)) D ERRX("ORB")
 Q
CURNODE() ; Return a global/local variable name based on VVSTACK
 ; Expects VVSTACK to be defined already
 N VVI,VVSUBS
 S VVSUBS=""
 F VVI=1:1:VVSTACK S:VVI>1 VVSUBS=VVSUBS_"," D
 . ; check numeric with pattern match instead of =+var due to GT.M interperting
 . ; scientific notation as a number instead of a string
 . I VVSTACK(VVI)?1N.N S VVSUBS=VVSUBS_VVSTACK(VVI) ; VEN/SMH Fix psudo array bug.
 . E  S VVSUBS=VVSUBS_""""_VVSTACK(VVI)_""""
 Q VVROOT_VVSUBS_")"
 ;
UES(X,KEY) ; Unescape JSON string
 ; copy segments from START to POS-2 (right before \)
 ; translate target character (which is at $F position)
 N POS,Y,START
 S POS=0,Y=""
 F  S START=POS+1 D  Q:START>$L(X)
 . S POS=$F(X,"\",START) ; find next position
 . I 'POS S Y=Y_$E(X,START,$L(X)),POS=$L(X) Q
 . ; otherwise handle escaped char
 . N TGT
 . S TGT=$E(X,POS),Y=Y_$E(X,START,POS-2)
 . I TGT="u" S Y=Y_$C($$DEC^%webutils($E(X,POS+1,POS+4),16)),POS=POS+4 Q
 . S Y=Y_$$REALCHAR(TGT,$G(KEY))
 Q Y
 ;
REALCHAR(C,KEY) ; Return actual character from escaped
 I C=""""&'$G(KEY) Q """" ; Used in the value part and doesn't need double quotes
 I C=""""&$G(KEY) Q """""" ; Used as part of a set statement and needs double quotes
 I C="/" Q "/"
 I C="\" Q "\"
 I C="b" Q $C(8)
 I C="f" Q $C(12)
 I C="n" Q $C(10)
 I C="r" Q $C(13)
 I C="t" Q $C(9)
 I C="u" ;case covered above in $$DEC^%webutils calls
 ;otherwise
 I $L($G(VVERR)) D ERRX("ESC",C)
 Q C
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 D ERRX^%webjson(ID,$G(VAL))
 Q
 ;
 ; Portions of this code are public domain, but it was extensively modified
 ; Copyright 2016 Accenture Federal Services
 ; Copyright 2013-2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%webjsonTestData1
VPRJUJ01 ;SLC/KCM -- Sample data for JSON decoding;2019-07-16  2:18 PM
 ;
 ;
 ; Portions of this code are public domain, but it was extensively modified
 ; Copyright 2016 Accenture Federal Services
 ; Copyright 2013-2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.
 ;
 ; --- Data for multi-line tests
 ;
SPLIT ;;
 ;;{"name":"value","comments":"here comes some whitespace"
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc": "this contains \\
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; \"quoted text\"", "nextLineQuote":"here is another string
 ;;"}
 ;;#####
 ;
SPLITC ;;
 ;;{"uid":"urn:va:2C0A:8:task:28","summary":"tast2","facilityCode":"500","taskName":"tast2","assignToName":"SQA,ONE",
 ;;"assignToCode":"urn:va:user:2C0A:1134","ownerName":"SQA,ONE","ownerCode":"urn:va:user:2C0A:1134
 ;;","description":"test","completed":f
 ;;alse,"dueDate":"20121128","kind":"Task"}
 ;;#####
 ;
VALONLY ;;
 ;;{"uid":"urn:va:param:F484:1120:VPR USER PREF:1120","entity":"USR","entityId":"1120","param":"VPR USER PREF","instance":"1120","vals":{"ext.libver":"/lib/ext-4.0.7/ext-all-dev.js","cpe.patientpicker.loc":"north"}}
 ;
NUMERIC ;;
 ;;{"name":"Duck,Donald","hl7Time":"20120919","count":234567,"icd":"722.10"}
BADQUOTE ;;
 ;;{"name":"value","comments":"here comes some whitespace"
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a
 ;;string that goes across two lines", "esc: "this string contains \\
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"}
 ;;#####
 ;
BADSLASH ;;
 ;;{"name":"value","comments":"here comes some whitespace"
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a
 ;;string that goes across two lines", "esc": "this string contains \
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"}
 ;;#####
 ;
BADBRACE ;;
 ;;{"test":[4,3,2]}}
 ;;#####
 ;
BADCOMMA ;;
 ;;{"test":[4,3,2]},
 ;;#####
 ;
PSNUM ;; Psudo-neumeric tests
 ;;{
 ;;"0.85,0.01":{"AUDIT":"TEST1","AUDIT CONDITION":"TEST2"},
 ;;"0.85,0.02":{"AUDIT":"TEST3","AUDIT CONDITION":"TEST4"},
 ;;"0.85,0.03":{"AUDIT":"TEST5","AUDIT CONDITION":"TEST6"}
 ;;}
 ;;#####
 ;
NUMLABEL ;;
 ;;{"syncStatusByVistaSystemId":{"9E99":{"patientUid":"urn:va:patient:9E99:46570:46570","dfn":"46570",
 ;;"domainExpectedTotals":{},"syncComplete":false}},"forOperational":true,  "syncOperationalComplete":false,
 ;;"uid":"urn:va:syncstatus:null",  "summary":"gov.va.cpe.vpr.sync.SyncStatus@35e797cf"}
 ;;#####
 ;
PURENUM1 ;; Label as plain number (not exponential number)
 ;;{"uid":"urn:va:syncstatus:OPD","summary":"gov.va.cpe.vpr.sync.SyncStatus@2c1cebdb","syncComplete":true,"syncStarted":true,
 ;;"forOperational":"true","syncStatusByVistaSystemId":{"1234":{"syncComplete":"true","domainExpectedTotals":{"bar":
 ;;{"total":100,"count":50}}}}}
 ;;#####
PURENUM2 ;; same as PURENUM1 but labels are in alpha order to match M subscripting
 ;;{"forOperational":"true","summary":"gov.va.cpe.vpr.sync.SyncStatus@2c1cebdb","syncComplete":true,"syncStarted":true,
 ;;"syncStatusByVistaSystemId":{"1234":{"domainExpectedTotals":{"bar":{"count":50,"total":100}},"syncComplete":"true"}},
 ;;"uid":"urn:va:syncstatus:OPD"}
 ;;#####
STRTYPES ;; strings that may be confused with other types
 ;;{"uid": "urn:va:syncstatus:OPD","syncStatusByVistaSystemId": {"1234": {"syncComplete" : "true"}}}
 ;;#####
 ;
ESTRING ;;
 ;;{"a":"influenza","b":"32E497ABC","c":0.123,"d":"0.321","e":-0.789,"f":"-0.987","g":3e22,"h":"2E8","i":1234}
 ;;#####
 ;
 ; --- SAMPLE JSON strings
 ;
SAM1 ;;
 ;;{"menu":{"id":"file","popup":{"menuitem":[{"value": "New","onclick":"CreateNewDoc()"},
 ;;{"value": "Open","onclick": "OpenDoc()"},{"value": "Close","onclick": "CloseDoc()"}]} ,
 ;;"value":"File"}}
 ;;#####
 ;
SAM2 ;;
 ;;    {
 ;;        "glossary": {
 ;;            "title": "example glossary",
 ;;            "GlossDiv": {
 ;;                "title": "S",
 ;;                "GlossList": {
 ;;                    "GlossEntry": {
 ;;                        "ID": "SGML",
 ;;                        "SortAs": "SGML",
 ;;                        "GlossTerm": "Standard Generalized Markup Language",
 ;;                        "Acronym": "SGML",
 ;;                        "Abbrev": "ISO 8879:1986",
 ;;                        "GlossDef": {
 ;;                            "para": "A meta-markup language, used to create markup languages such as DocBook.",
 ;;                            "GlossSeeAlso": ["GML", "XML"]
 ;;                        },
 ;;                        "GlossSee": "markup"
 ;;                    }
 ;;                }
 ;;            }
 ;;        }
 ;;    }
 ;;#####
 ;
SAM3 ;;
 ;;    {"widget": {
 ;;        "debug": "on",
 ;;        "window": {
 ;;            "title": "Sample Konfabulator Widget",
 ;;            "name": "main_window",
 ;;            "width": 500,
 ;;            "height": 500
 ;;        },
 ;;        "image": {
 ;;            "src": "Images/Sun.png",
 ;;            "name": "sun1",
 ;;            "hOffset": 250,
 ;;            "vOffset": 250,
 ;;            "alignment": "center"
 ;;        },
 ;;        "text": {
 ;;            "data": "Click Here",
 ;;            "size": 36,
 ;;            "style": "bold",
 ;;            "name": "text1",
 ;;            "hOffset": 250,
 ;;            "vOffset": 100,
 ;;            "alignment": "center",
 ;;            "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"
 ;;        }
 ;;    }}
 ;;#####
 ;
SAM4 ;;
 ;;    {"web-app": {
 ;;      "servlet": [
 ;;        {
 ;;          "servlet-name": "cofaxCDS",
 ;;          "servlet-class": "org.cofax.cds.CDSServlet",
 ;;          "init-param": {
 ;;            "configGlossary:installationAt": "Philadelphia, PA",
 ;;            "configGlossary:adminEmail": "ksm@pobox.com",
 ;;            "configGlossary:poweredBy": "Cofax",
 ;;            "configGlossary:poweredByIcon": "/images/cofax.gif",
 ;;            "configGlossary:staticPath": "/content/static",
 ;;            "templateProcessorClass": "org.cofax.WysiwygTemplate",
 ;;            "templateLoaderClass": "org.cofax.FilesTemplateLoader",
 ;;            "templatePath": "templates",
 ;;            "templateOverridePath": "",
 ;;            "defaultListTemplate": "listTemplate.htm",
 ;;            "defaultFileTemplate": "articleTemplate.htm",
 ;;            "useJSP": false,
 ;;            "jspListTemplate": "listTemplate.jsp",
 ;;            "jspFileTemplate": "articleTemplate.jsp",
 ;;            "cachePackageTagsTrack": 200,
 ;;            "cachePackageTagsStore": 200,
 ;;            "cachePackageTagsRefresh": 60,
 ;;            "cacheTemplatesTrack": 100,
 ;;            "cacheTemplatesStore": 50,
 ;;            "cacheTemplatesRefresh": 15,
 ;;            "cachePagesTrack": 200,
 ;;            "cachePagesStore": 100,
 ;;            "cachePagesRefresh": 10,
 ;;            "cachePagesDirtyRead": 10,
 ;;            "searchEngineListTemplate": "forSearchEnginesList.htm",
 ;;            "searchEngineFileTemplate": "forSearchEngines.htm",
 ;;            "searchEngineRobotsDb": "WEB-INF/robots.db",
 ;;            "useDataStore": true,
 ;;            "dataStoreClass": "org.cofax.SqlDataStore",
 ;;            "redirectionClass": "org.cofax.SqlRedirection",
 ;;            "dataStoreName": "cofax",
 ;;            "dataStoreDriver": "com.microsoft.jdbc.sqlserver.SQLServerDriver",
 ;;            "dataStoreUrl": "jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon",
 ;;            "dataStoreUser": "sa",
 ;;            "dataStorePassword": "dataStoreTestQuery",
 ;;            "dataStoreTestQuery": "SET NOCOUNT ON;select test='test';",
 ;;            "dataStoreLogFile": "/usr/local/tomcat/logs/datastore.log",
 ;;            "dataStoreInitConns": 10,
 ;;            "dataStoreMaxConns": 100,
 ;;            "dataStoreConnUsageLimit": 100,
 ;;            "dataStoreLogLevel": "debug",
 ;;            "maxUrlLength": 500}},
 ;;        {
 ;;          "servlet-name": "cofaxEmail",
 ;;          "servlet-class": "org.cofax.cds.EmailServlet",
 ;;          "init-param": {
 ;;          "mailHost": "mail1",
 ;;          "mailHostOverride": "mail2"}},
 ;;        {
 ;;          "servlet-name": "cofaxAdmin",
 ;;          "servlet-class": "org.cofax.cds.AdminServlet"},
 ;;
 ;;        {
 ;;          "servlet-name": "fileServlet",
 ;;          "servlet-class": "org.cofax.cds.FileServlet"},
 ;;        {
 ;;          "servlet-name": "cofaxTools",
 ;;          "servlet-class": "org.cofax.cms.CofaxToolsServlet",
 ;;          "init-param": {
 ;;            "templatePath": "toolstemplates/",
 ;;            "log": 1,
 ;;            "logLocation": "/usr/local/tomcat/logs/CofaxTools.log",
 ;;            "logMaxSize": "",
 ;;            "dataLog": 1,
 ;;            "dataLogLocation": "/usr/local/tomcat/logs/dataLog.log",
 ;;            "dataLogMaxSize": "",
 ;;            "removePageCache": "/content/admin/remove?cache=pages&id=",
 ;;            "removeTemplateCache": "/content/admin/remove?cache=templates&id=",
 ;;            "fileTransferFolder": "/usr/local/tomcat/webapps/content/fileTransferFolder",
 ;;            "lookInContext": 1,
 ;;            "adminGroupID": 4,
 ;;            "betaServer": true}}],
 ;;      "servlet-mapping": {
 ;;        "cofaxCDS": "/",
 ;;        "cofaxEmail": "/cofaxutil/aemail/*",
 ;;        "cofaxAdmin": "/admin/*",
 ;;        "fileServlet": "/static/*",
 ;;        "cofaxTools": "/tools/*"},
 ;;
 ;;      "taglib": {
 ;;        "taglib-uri": "cofax.tld",
 ;;        "taglib-location": "/WEB-INF/tlds/cofax.tld"}}}
 ;;#####
 ;
SAM5 ;;
 ;;    {"menu": {
 ;;        "header": "SVG Viewer",
 ;;        "items": [
 ;;            {"id": "Open"},
 ;;            {"id": "OpenNew", "label": "Open New"},
 ;;            null,
 ;;            {"id": "ZoomIn", "label": "Zoom In"},
 ;;            {"id": "ZoomOut", "label": "Zoom Out"},
 ;;            {"id": "OriginalView", "label": "Original View"},
 ;;            null,
 ;;            {"id": "Quality"},
 ;;            {"id": "Pause"},
 ;;            {"id": "Mute"},
 ;;            null,
 ;;            {"id": "Find", "label": "Find..."},
 ;;            {"id": "FindAgain", "label": "Find Again"},
 ;;            {"id": "Copy"},
 ;;            {"id": "CopyAgain", "label": "Copy Again"},
 ;;            {"id": "CopySVG", "label": "Copy SVG"},
 ;;            {"id": "ViewSVG", "label": "View SVG"},
 ;;            {"id": "ViewSource", "label": "View Source"},
 ;;            {"id": "SaveAs", "label": "Save As"},
 ;;            null,
 ;;            {"id": "Help"},
 ;;            {"id": "About", "label": "About Adobe CVG Viewer..."}
 ;;        ]
 ;;    }}
 ;;#####
 ;
MAXNUM ;; String that appears to be large number
 ;;{"pid":"33","taskName":"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678903123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789041234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890512345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789012345678901234567890123456789012345678906123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789071234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789081234567890123456
 ;;7890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890912345678901234567890123456789012345678901234567890123456
 ;;789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890","description":"this task title is well over 256 characters but they are all numeric<br>","type"
 ;;:"General","dueDate":"20130110000000.000","completed":null,"ownerName":"AVIVAUSER,FORTYTWO","ownerCode":"urn:va:user:2C0A:1136","assignToName":"AVIVAUSER,FORTYTWO","assignToCode":"urn:va:user:2C0A:1136","facilityCode":"500","facilityName":"C
 ;;AMP MASTER"}
 ;;#####
ESCQ ;; String with an escaped quote across lines
 ;;{"uid":"urn:test:47","comments":"This has a line with an escaped quote (\
 ;;") across lines."}
 ;;#####
ESCQ2 ;; String with escaped slash and escaped quote
 ;;{"uid":"urn:va:viewdefdef:F484:232","name":"A big board","bjw":"a long escaped string: [\\\"DIET\\\",\\\"MEAL\
 ;;\\"]","updated":"20130320143825"}
 ;;#####

%webjsonEncodeTest
%webjsonEncodeTest ;SLC/KCM -- Unit tests for JSON encoding;2019-11-14  9:08 AM
 ;
 D EN^%ut($T(+0),3)
 quit
 ;
STARTUP  ; Run once before all tests
 if $p($sy,",")=47 VIEW "TRACE":1:"^%wtrace"
 Q
SHUTDOWN ; Run once after all tests
 if $p($sy,",")=47 VIEW "TRACE":0:"^%wtrace"
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D CHKEQ^%ut(EXPECT,ACTUAL)
 Q
 ;
NUMERIC ;; @TEST is numeric function
 D ASSERT(0,$$NUMERIC^%webjsonEncode("2COWS"))
 D ASSERT(0,$$NUMERIC^%webjsonEncode("007"))
 D ASSERT(0,$$NUMERIC^%webjsonEncode(".4"))
 D ASSERT(1,$$NUMERIC^%webjsonEncode("0.4"))
 D ASSERT(0,$$NUMERIC^%webjsonEncode("-.4"))
 D ASSERT(1,$$NUMERIC^%webjsonEncode("-0.4"))
 D ASSERT(1,$$NUMERIC^%webjsonEncode(0))
 D ASSERT(0,$$NUMERIC^%webjsonEncode(".0"))
 D ASSERT(1,$$NUMERIC^%webjsonEncode(3.1416))
 D ASSERT(1,$$NUMERIC^%webjsonEncode("2.3E-2"))
 D ASSERT(1,$$NUMERIC^%webjsonEncode(0.4E12))
 D ASSERT(0,$$NUMERIC^%webjsonEncode(".4E-12"))
 Q
NEARZERO ;; @TEST encode of numbers near 0
 ;;{"s":"0.5","t":"-0.6","x":0.42,"y":-0.44}
 N X,JSON,ERR
 S X("s")="0.5",X("s","\s")=""
 S X("t")="-0.6",X("t","\s")=""
 S X("x")=0.42
 S X("y")=-0.44
 D ENCODE^%webjson("X","JSON","ERR")
 D ASSERT($P($T(NEARZERO+1),";;",2,99),JSON(1))
 Q
JSONESC ;; @TEST create JSON escaped string
 N X
 S X=$$ESC^%webjson("String with \ in the middle")
 D ASSERT("String with \\ in the middle",X)
 S X=$$ESC^%webjson("\ is the first character of this string")
 D ASSERT("\\ is the first character of this string",X)
 S X=$$ESC^%webjson("The last character of this string is \")
 D ASSERT("The last character of this string is \\",X)
 S X=$$ESC^%webjson("\one\two\three\")
 D ASSERT("\\one\\two\\three\\",X)
 S X=$$ESC^%webjson("A vee shape: \/"_$C(9)_"TABBED"_$C(9)_"and line endings."_$C(10,13,12))
 D ASSERT("A vee shape: \\\/\tTABBED\tand line endings.\n\r\f",X)
 S X=$$ESC^%webjson("""This text is quoted""")
 D ASSERT("\""This text is quoted\""",X)
 S X=$$ESC^%webjson("This text contains an embedded"_$C(26)_" control character")
 D ASSERT("This text contains an embedded\u001A control character",X)
 S X=$$ESC^%webjson("This contains tab"_$C(9)_" and control"_$C(22)_" characters")
 D ASSERT("This contains tab\t and control\u0016 characters",X)
 S X=$$ESC^%webjson("This has embedded NUL"_$C(0)_" character.")
 D ASSERT("This has embedded NUL character.",X)
 Q
BASIC ;; @TEST encode basic object as JSON
 N X,JSON
 S X("myObj","booleanT")="true"
 S X("myObj","booleanF")="false"
 S X("myObj","numeric")=3.1416
 S X("myObj","nullValue")="null"
 S X("myObj","array",1)="one"
 S X("myObj","array",2)="two"
 S X("myObj","array",3)="three"
 S X("myObj","subObject","fieldA")="hello"
 S X("myObj","subObject","fieldB")="world"
 D ENCODE^%webjson("X","JSON")
 D ASSERT($$TARGET("BASIC"),JSON(1)_JSON(2))
 Q
VALS ;; @TEST encode simple values only object as JSON
 N X,JSON
 S X("prop1")="property1"
 S X("bool1")="true"
 S X("num1")="2.1e3",X("num1","\n")=""
 S X("arr",1)="apple"
 S X("arr",2)="orange"
 S X("arr",3)="pear"
 S X("arr",4,"obj")="4th array item is object"
 D ENCODE^%webjson("X","JSON")
 D ASSERT($$TARGET("VALS"),JSON(1)_JSON(2))
 Q
LONG ;; @TEST encode object with continuation nodes for value
 N X,I,JSON,FILLER,TARGET
 S FILLER=", this will extend the line out to at least 78 characters."_$C(10)
 S X("title")="My note test title"
 S X("note")="This is the first line of the note.  Here are ""quotes"" and a \ and a /."_$C(10)
 F I=1:1:60 S X("note","\",I)="Additional Line #"_I_FILLER
 D ENCODE^%webjson("X","JSON")
 S TARGET=$$TARGET("LONG")
 D ASSERT(TARGET,$E(JSON(1)_JSON(2)_JSON(3),1,$L(TARGET)))
 D ASSERT(1,$D(JSON(62)))
 D ASSERT(0,$D(JSON(63)))
 S TARGET="t least 78 characters.\n"",""title"":"
 D ASSERT(TARGET,$E(JSON(61),$L(JSON(61))-$L(TARGET)+1,$L(JSON(61))))
 Q
PRE ;; @TEST encode object where parts are already JSON encoded
 N X,JSON,TARGET
 S X("count")=3
 S X("menu",1,":",1)=$$TARGET("NODES",1)
 S X("menu",2,":",1)=$$TARGET("NODES",2)
 S X("menu",3,":",1)=$$TARGET("NODES",3)
 S X("template",":")=$$TARGET("NODES",4)
 D ENCODE^%webjson("X","JSON")
 S TARGET=$$TARGET("PRE",1)_$$TARGET("PRE",2)
 D ASSERT(TARGET,JSON(1)_JSON(2)_JSON(3))
 Q
WP ;; @TEST word processing nodes inside object
 N Y,JSON,TARGET,ERR
 D BUILDY("WP")
 D ENCODE^%webjson("Y","JSON","ERR")
 D ASSERT(0,$D(ERR))
 S TARGET=$$TARGET("WPOUT")_$$TARGET("WPOUT",2)_$$TARGET("WPOUT",3)
 D ASSERT(TARGET,JSON(1)_JSON(2)_JSON(3)_JSON(4)_JSON(5)_JSON(6)_JSON(7))
 Q
LTZERO ;; @TEST leading / trailing zeros get preserved
 N Y,JSON,TARGET
 S Y("count")=737
 S Y("ssn")="000427930"
 S Y("icd")="626.00"
 S Y("price")=".65" ;M still treats this as a number, so in JSON it's 0.65
 S Y("code")=".77",Y("code","\s")=""
 S Y("errors")=0
 D ENCODE^%webjson("Y","JSON")
 D ASSERT($$TARGET("LTZERO"),JSON(1))
 Q
STRINGS ;; @TEST force encoding as string
 N Y,JSON,TARGET,ERR
 S Y("count")=234567
 S Y("hl7Time")="20120919"
 S Y("hl7Time","\s")=""
 S Y("icd")="722.10"
 S Y("name")="Duck,Donald"
 D ENCODE^%webjson("Y","JSON","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT($$TARGET("STRINGS"),JSON(1))
 Q
LABELS ;; @TEST unusual labels
 ;;{"top":[{"10":"number 10",",":"comma",":":"colon","\\":"backslash","a":"normal letter"}]}
 ;
 ; NOTE: we don't allow a label to contain a quote (")
 N Y,JSON,ERR,Y2
 S Y("top",1,":")="colon"
 S Y("top",1,"\")="backslash"
 S Y("top",1,",")="comma"
 S Y("top",1,"a")="normal letter"
 S Y("top",1,"""10")="number 10"
 D ENCODE^%webjson("Y","JSON","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT($P($T(LABELS+1),";;",2,99),JSON(1))
 Q
EXAMPLE ;; @TEST encode samples that are on JSON.ORG
 N Y,JSON,TARGET
 D BUILDY("EX1IN")
 D ENCODE^%webjson("Y","JSON")
 S TARGET=$$TARGET("EX1OUT")
 D ASSERT(TARGET,JSON(1)_JSON(2))
 D BUILDY("EX2IN")
 D ENCODE^%webjson("Y","JSON")
 S TARGET=$$TARGET("EX2OUT")_$$TARGET("EX2OUT",2)
 D ASSERT(TARGET,JSON(1)_JSON(2)_JSON(3)_JSON(4)_JSON(5))
 D BUILDY("EX3IN")
 D ENCODE^%webjson("Y","JSON")
 S TARGET=$$TARGET("EX3OUT")_$$TARGET("EX3OUT",2)
 D ASSERT(TARGET,JSON(1)_JSON(2)_JSON(3)_JSON(4))
 D BUILDY("EX4IN")
 D ENCODE^%webjson("Y","JSON")
 S TARGET=$$TARGET("EX4OUT")
 D ASSERT(TARGET,$E(JSON(1)_JSON(2)_JSON(3),1,215))
 D ASSERT(95,$L(JSON(1)))
 Q
KEYESC ;; @TEST keys should be escaped
 N Y,JSON,TARGET
 S Y("names","x(834038,""237745"":""240474"")")="AREG"
 D ENCODE^%webjson("Y","JSON")
 D ASSERT(JSON(1),"{""names"":{""x(834038,\""237745\"":\""240474\"")"":""AREG""}}")
 Q
EXTARRAY ;; @TEST No top object; first level is an array
 ; Bug reported by Winfried on comp.lang.mumps
 n t,t2
 s t="[{""s"":1,""n"":123},{""N1"":true,""N2"":""true""}]"
 d decode^%webjsonDecode("t","json","jerr")
 D ASSERT($d(jerr),0)
 k jerr
 d encode^%webjsonEncode("json","t2","jerr")
 D ASSERT($d(jerr),0)
 D ASSERT(t2(1),"[{""n"":123,""s"":1},{""N1"":true,""N2"":""true""}]")
 quit
 ;
BUILDY(LABEL) ; build Y array based on LABEL
 ; expects Y from EXAMPLE
 N I,X
 K Y
 F I=1:1 S X=$P($T(@LABEL+I^%webjsonTestData2),";;",2,999) Q:X="zzzzz"  X "S "_X
 Q
TARGET(ID,OFFSET) ; values to test against
 S OFFSET=$G(OFFSET,1)
 Q $P($T(@ID+OFFSET^%webjsonTestData2),";;",2,999)
 ;
 ; Portions of this code are public domain, but it was extensively modified
 ; Copyright 2016 Accenture Federal Services
 ; Copyright 2013-2019 Sam Habiel
 ; Copyright 2019 Christopher Edwards
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%webtest
%webtest ; ose/smh - Web Services Tester;2019-11-14  11:53 AM
 ; Runs only on GTM/YDB
 ; Requires M-Unit
 ;
test if $text(^%ut)="" quit
 if $p($sy,",")'=47 quit
 do EN^%ut($t(+0),3)
 do cov
 quit
 ;
STARTUP ; [Adjust the acvc and dfn to suit your environment]
 set acvc="SM1234;SM1234!!"
 set dfn=463
 kill ^%wtrace,^%wcohort,^%wsurv
 VIEW "TRACE":1:"^%wtrace"
 kill ^%webhttp("log")
 kill ^%webhttp(0,"logging")
 do resetURLs
 job start^%webreq(55728,,,,1,,,"Y","Content-Type","OPTIONS, POST","*","true",86400):(IN="/dev/null":OUT="/dev/null":ERR="/dev/null"):5
 set myJob=$zjob
 hang .1
 quit
 ;
SHUTDOWN ;
 open "p":(command="$gtm_dist/mupip stop "_myJob)::"pipe"
 use "p" r x:1
 close "p"
 w !,x,!
 ;
 kill acvc,myJob
 ;
 VIEW "TRACE":0:"^%wtrace"
 quit
 ;
tdebug ; @TEST Debug Entry Point
 job start^%webreq(55729,1,,,1):(IN="/dev/null":OUT="/dev/null":ERR="/dev/null"):5
 h .1
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55729/")
 do CHKEQ^%ut(httpStatus,200)
 do CHKTF^%ut(return["MUMPS Restful Web-Services Portal")
 ; and it halts on its own
 quit
 ;
thome ; @TEST Test Home Page
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/")
 do CHKEQ^%ut(httpStatus,200)
 do CHKTF^%ut(return["MUMPS Restful Web-Services Portal")
 quit
 ;
tgetr ; @TEST Test Get Handler Routine
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/r/%25webapi")
 do CHKEQ^%ut(httpStatus,200)
 do CHKTF^%ut(return["divergence in case an index is requested")
 quit
 ;
tputr ; @TEST Put a Routine
 i $text(^XUS)="" quit  ; VistA not installed
 n httpStatus,return,headers
 n random s random=$R(9817238947)
 n payload s payload="KBANTESTWEB ;"_random_$C(13,10)_" W ""HELLO WORLD"",!"_$C(13,10)_" QUIT"
 d &libcurl.init
 d &libcurl.auth("Basic",$tr(acvc,";",":"))
 d &libcurl.do(.httpStatus,.return,"PUT","http://127.0.0.1:55728/r/KBANTESTWEB",payload,"application/text",1,.headers)
 do CHKEQ^%ut(httpStatus,201)
 d &libcurl.cleanup
 k httpStatus,return
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/r/KBANTESTWEB")
 do CHKTF^%ut(return[random)
 quit
 ;
tgetxml ; @TEST Test Get Handler XML
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/test/xml")
 do CHKEQ^%ut(httpStatus,200)
 do CHKTF^%ut(return["xml")
 quit
 ;
thead ; #TEST HTTP Verb HEAD (only works with GET queries)
 ; my libcurl doesn't do HEAD :-( - but head works
 n httpStatus,return,headers,status
 d
 . n $et,$es s $et="s ec=$ec,$ec="""""
 . s status=$&libcurl.curl(.httpStatus,.return,"HEAD","http://127.0.0.1:55728/test/xml",,,1,.headers)
 zwrite ec
 zwrite httpStatus
 zwrite headers
 quit
 ;
tgzip ; @TEST Test gzip encoding
 n httpStatus,return,headers
 d &libcurl.init
 d &libcurl.addHeader("Accept-Encoding: gzip")
 n status s status=$&libcurl.do(.httpStatus,.return,"GET","http://127.0.0.1:55728/r/%25webapi",,,1,.headers)
 do CHKEQ^%ut(httpStatus,200)
 do CHKTF^%ut(headers["Content-Encoding: gzip")
 view "nobadchar"
 do CHKTF^%ut(return[$C(0))
 view "badchar"
 quit
 ;
tnogzipflag ; @TEST Test nogzip flag
 k ^%webhttp("log",+$H)
 n gzipflagjob
 ;
 ; Now start a webserver with a passed username/password
 j start^%webreq(55732,"",,,,,1)
 h .1
 s gzipflagjob=$zjob
 ;
 n httpStatus,return,headers
 d &libcurl.init
 d &libcurl.addHeader("Accept-Encoding: gzip") ; This must be sent to properly test as the server is smart and if we don't send that we support gzip it won't gzip
 n status s status=$&libcurl.do(.httpStatus,.return,"GET","http://127.0.0.1:55732/r/%25webapi",,,1,.headers)
 do CHKEQ^%ut(httpStatus,200)
 do CHKTF^%ut(headers'["Content-Encoding: gzip")
 do CHKTF^%ut(return["webapi ; OSE/SMH - Infrastructure web services hooks")
 ;
 ; now stop the webserver again
 open "p":(command="$gtm_dist/mupip stop "_gzipflagjob)::"pipe"
 use "p" r x:1
 close "p"
 w !,x,!
 ;
 kill gzipflagjob
 quit
 ;
temptynogzip ; @TEST Empty response with no gzip encoding
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/test/empty")
 do CHKEQ^%ut(httpStatus,200)
 do CHKTF^%ut(return="")
 quit
 ;
temptygzip ; @TEST Empty response with gzip
 n httpStatus,return
 d &libcurl.init
 d &libcurl.addHeader("Accept-Encoding: gzip")
 n status s status=$&libcurl.do(.httpStatus,.return,"GET","http://127.0.0.1:55728/test/empty",,,1,.headers)
 do CHKEQ^%ut(httpStatus,200)
 do CHKTF^%ut(headers'["Content-Encoding: gzip")
 do CHKTF^%ut(return="")
 quit
 ;
tping ; @TEST Ping
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/ping")
 do CHKEQ^%ut(httpStatus,200)
 do CHKTF^%ut(return["running")
 quit
 ;
terr ; @TEST generating an error
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/test/error")
 do CHKEQ^%ut(httpStatus,500)
 quit
 ;
terr2 ; @TEST crashing the error trap
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/test/error?foo=crash2")
 do CHKEQ^%ut(httpStatus,500)
 quit
 ;
tcustomError ; @TEST Custom Error
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/test/customerror")
 do CHKTF^%ut(return["OperationOutcome")
 do CHKEQ^%ut(httpStatus,400)
 quit
 ;
tlong ; @TEST get a long message
 ; Exercises the flushing
 n httpStatus,return
 n status s status=$&libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/bigoutput")
 do CHKEQ^%ut(httpStatus,200)
 do CHKEQ^%ut($l(return),32769)
 quit
 ;
trpc1 ; @TEST Run a VistA RPC w/o authentication - should fail
 n httpStatus,return
 i $text(^XUS)="" quit  ; VistA not installed
 n payload s payload="['A','1']"
 n % s %("'")=""""
 s payload=$$REPLACE^XLFSTR(payload,.%)
 d &libcurl.init
 d &libcurl.do(.httpStatus,.return,"POST","http://127.0.0.1:55728/rpc/ORWU%20NEWPERS",payload,"application/json")
 d &libcurl.cleanup
 d CHKEQ^%ut(httpStatus,401)
 quit

trpc2 ; @TEST Run a VistA RPC (requires authentication - ac/vc provided)
 n httpStatus,return
 i $text(^XUS)="" quit  ; VistA not installed
 n payload s payload="['A','1']"
 n % s %("'")=""""
 s payload=$$REPLACE^XLFSTR(payload,.%)
 d &libcurl.init
 d &libcurl.auth("Basic",$tr(acvc,";",":"))
 d &libcurl.do(.httpStatus,.return,"POST","http://127.0.0.1:55728/rpc/ORWU%20NEWPERS",payload,"application/json")
 d &libcurl.cleanup
 d CHKEQ^%ut(httpStatus,201)
 ; output like: "63^Cprs,User"_$C(13,10)_"1^Manager,System"_$C(13,10)_"137^Pharmacist,Unknown Synthea"_$C(13,10)_".5^Postmaster"_$C(13,10)_"136^Provider,Unknown Synthea"_$C(13,10)
 d CHKTF^%ut(+return)
 d CHKTF^%ut(return[$C(13,10))
 quit
 ;
trpc3 ; @TEST Run the VPR RPC (XML Version)
 n httpStatus,return
 i $text(^XUS)="" quit  ; VistA not installed
 n payload s payload="[1]"
 d &libcurl.init
 d &libcurl.auth("Basic",$tr(acvc,";",":"))
 d &libcurl.do(.httpStatus,.return,"POST","http://127.0.0.1:55728/rpc/VPR%20GET%20PATIENT%20DATA",payload,"application/json")
 d &libcurl.cleanup
 d CHKEQ^%ut(httpStatus,201)
 d CHKTF^%ut(return["<")
 quit
trpc4 ; @TEST Run the VPR RPC (JSON Version)
 n httpStatus,return
 i $text(^XUS)="" quit  ; VistA not installed
 n payload s payload="[{'patientId': '"_dfn_"', 'domain': ''}]"
 n % s %("'")=""""
 s payload=$$REPLACE^XLFSTR(payload,.%)
 d &libcurl.init
 d &libcurl.auth("Basic",$tr(acvc,";",":"))
 d &libcurl.do(.httpStatus,.return,"POST","http://127.0.0.1:55728/rpc/VPR%20GET%20PATIENT%20DATA%20JSON",payload,"application/json")
 d &libcurl.cleanup
 d CHKEQ^%ut(httpStatus,201)
 d CHKTF^%ut(return["{")
 quit
 ;
tParams ; @TEST Test a web service with parameters
 n httpStatus,return
 i $text(^XUS)="" quit  ; VistA not installed
 n payload s payload="start=A&direction=1"
 d &libcurl.init
 d &libcurl.auth("Basic",$tr(acvc,";",":"))
 d &libcurl.do(.httpStatus,.return,"POST","http://127.0.0.1:55728/rpc2/ORWU%20NEWPERS",payload)
 d &libcurl.cleanup
 d CHKEQ^%ut(httpStatus,201)
 ; output like: "63^Cprs,User"_$C(13,10)_"1^Manager,System"_$C(13,10)_"137^Pharmacist,Unknown Synthea"_$C(13,10)_".5^Postmaster"_$C(13,10)_"136^Provider,Unknown Synthea"_$C(13,10)
 d CHKTF^%ut(+return)
 d CHKTF^%ut(return[$C(13,10))
 quit
 ;
tDC ; @TEST Test Disconnecting from the Server w/o talking
 open "sock":(connect="127.0.0.1:55728:TCP":attach="client"):1:"socket"
 else  D FAIL^%ut("Failed to connect to server") quit
 close "sock"
 quit
 ;
tInt ; @TEST ZInterrupt
 open "p":(command="$gtm_dist/mupip intrpt "_myJob)::"pipe"
 use "p" r x:1
 close "p"
 h .1
 d CHKTF^%ut($d(^%webhttp("processlog",$p($h,","))))
 k ^%webhttp("processlog")
 QUIT
 ;
tLog1 ; @TEST Set HTTPLOG to 1
 S ^%webhttp(0,"logging")=1
 K ^%webhttp("log",+$H)
 n httpStatus,return
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/ping")
 n s s s=$o(^%webhttp("log",+$h,""))
 d CHKTF^%ut(^%webhttp("log",+$h,s,1,"raw"))
 d CHKTF^%ut(^%webhttp("log",+$h,s,1,"req","header"))
 quit
 ;
tLog2 ; @TEST Set HTTPLOG to 2
 S ^%webhttp(0,"logging")=2
 K ^%webhttp("log",+$H)
 n httpStatus,return
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/ping")
 n s s s=$o(^%webhttp("log",+$h,""))
 d CHKTF^%ut(^%webhttp("log",+$h,s,1,"raw"))
 d CHKTF^%ut(^%webhttp("log",+$h,s,1,"req","header"))
 quit
 ;
tLog3 ; @TEST Set HTTPLOG to 3
 i $text(^XUS)="" quit  ; VistA not installed
 S ^%webhttp(0,"logging")=3
 K ^%webhttp("log",+$H)
 n httpStatus,return
 n payload s payload="['A','1']"
 n % s %("'")=""""
 s payload=$$REPLACE^XLFSTR(payload,.%)
 d &libcurl.init
 d &libcurl.auth("Basic",$tr(acvc,";",":"))
 d &libcurl.do(.httpStatus,.return,"POST","http://127.0.0.1:55728/rpc/ORWU%20NEWPERS",payload,"application/json")
 d &libcurl.cleanup
 d CHKEQ^%ut(httpStatus,201)
 ; output like: "63^Cprs,User"_$C(13,10)_"1^Manager,System"_$C(13,10)_"137^Pharmacist,Unknown Synthea"_$C(13,10)_".5^Postmaster"_$C(13,10)_"136^Provider,Unknown Synthea"_$C(13,10)
 d CHKTF^%ut(+return)
 d CHKTF^%ut(return[$C(13,10))
 n s s s=$o(^%webhttp("log",+$h,""))
 d CHKTF^%ut($d(^%webhttp("log",+$h,s,1,"response")))
 quit
 ;
tDCLog ; @TEST Test Disconnecting from the Server w/o talking while logging
 S ^%webhttp(0,"logging")=3
 K ^%webhttp("log",+$H)
 open "sock":(connect="127.0.0.1:55728:TCP":attach="client"):1:"socket"
 else  D FAIL^%ut("Failed to connect to server") quit
 close "sock"
 h .1
 n s s s=$o(^%webhttp("log",+$h,""))
 d CHKTF^%ut($d(^%webhttp("log",+$h,s,1,"disconnect")))
 quit
 ;
tWebPage ; @TEST Test Getting a web page
 new oldDir set oldDir=$g(^%webhome)
 set ^%webhome="/tmp/"
 zsy "mkdir -p /tmp/foo"
 new random s random=$R(9817234)
 open "/tmp/foo/boo.html":(newversion)
 use "/tmp/foo/boo.html"
 write "<!DOCTYPE html>",!
 write "<html>",!
 write "<body>",!
 write "<h1>My First Heading</h1>",!
 write "<p>My first paragraph."_random_"</p>",!
 write "</body>",!
 write "</html>",!
 close "/tmp/foo/boo.html"
 n httpStatus,return
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/foo/boo.html")
 d CHKEQ^%ut(httpStatus,200)
 d CHKTF^%ut(return[random)
 set ^%webhome="/tmp"
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55728/foo/boo.html")
 d CHKEQ^%ut(httpStatus,200)
 d CHKTF^%ut(return[random)
 set ^%webhome=oldDir
 quit
 ;
tINIT ; @TEST Test Fileman INIT code
 if $text(^DI)="" quit  ; no fileman
 ;
 ; Delete the old DD
 set DIU="^%web(17.6001,",DIU(0)="ES" do EN^DIU2
 do CHKTF^%ut('$data(^DD(17.6001)))
 do CHKTF^%ut('$data(^DD("IX","F",17.6001)))
 ;
 do ^%webINIT
 do CHKTF^%ut($data(^DD(17.6001)))
 do CHKTF^%ut($data(^DD("IX","F",17.6001)))
 quit
 ;
CORS ; @TEST Make sure CORS headers are returned
 k ^%webhttp("log",+$H)
 n httpStatus,return,headers,headerarray
 d &libcurl.curl(.httpStatus,.return,"OPTIONS","http://127.0.0.1:55728/r/kbbotest.m",,,,.headers)
 ;
 ; Split the headers apart using carriage return line feed delimiter
 f i=1:1:$L(headers,$C(13,10)) D
 . ; Change to name based subscripts by using ": " delimiter
 . s:($p($p(headers,$C(13,10),i),": ",1)'="")&($p($p(headers,$C(13,10),i),": ",2)'="") headerarray($p($p(headers,$C(13,10),i),": ",1))=$p($p(headers,$C(13,10),i),": ",2)
 ;
 ; Now make sure all required bits are correct
 d CHKEQ^%ut(httpStatus,200)
 d CHKEQ^%ut($g(headerarray("Access-Control-Allow-Methods")),"OPTIONS, POST")
 d CHKEQ^%ut($g(headerarray("Access-Control-Allow-Headers")),"Content-Type")
 d CHKEQ^%ut($g(headerarray("Access-Control-Max-Age")),"86400")
 d CHKEQ^%ut($g(headerarray("Access-Control-Allow-Origin")),"*")
 quit
 ;
USERPASS ; @TEST Test that passing a username/password works
 k ^%webhttp("log",+$H)
 n passwdJob
 ;
 ; Now start a webserver with a passed username/password
 j start^%webreq(55730,"",,,,"admin:admin")
 h .1
 s passwdJob=$zjob
 ;
 n httpStatus,return
 ;
 ; Positive test
 d &libcurl.init
 d &libcurl.auth("Basic","admin:admin")
 d &libcurl.do(.httpStatus,.return,"GET","http://127.0.0.1:55730/ping")
 d &libcurl.cleanup
 d CHKEQ^%ut(httpStatus,200)
 ;
 ; Negative test
 d &libcurl.init
 d &libcurl.auth("Basic","admin:12345")
 d &libcurl.do(.httpStatus,.return,"GET","http://127.0.0.1:55730/ping")
 d &libcurl.cleanup
 d CHKEQ^%ut(httpStatus,401)
 ;
 ; now stop the webserver again
 open "p":(command="$gtm_dist/mupip stop "_passwdJob)::"pipe"
 use "p" r x:1
 close "p"
 w !,x,!
 ;
 kill passwdJob
 quit
 ;
NOGBL ; @TEST Test to make sure no globals are used during webserver operations
 k ^%webhttp("log",+$H)
 k ^%webhttp(0,"listener")
 n nogblJob
 ;
 ; Now start a webserver with a passed username/password
 j start^%webreq(55731,"",,1,,,,"Y","Content-Type","OPTIONS, POST","*","true",86400)
 h .1
 s nogblJob=$zjob
 ;
 n httpStatus,return,headers
 ;
 ; check to make sure ^%webhome isn't used
 ; The default is the current directory
 new random s random=$R(9817234)
 new oldDir set oldDir=$g(^%webhome)
 s ^%webhome="/tmp/"_random
 open "test.html":(newversion)
 use "test.html"
 write "<!DOCTYPE html>",!
 write "<html>",!
 write "<body>",!
 write "<h1>My First Heading</h1>",!
 write "<p>My first paragraph."_random_"</p>",!
 write "</body>",!
 write "</html>",!
 close "test.html"
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55731/test.html")
 d CHKEQ^%ut(httpStatus,200)
 d CHKTF^%ut(return[random)
 open "p":(command="rm test.html")::"pipe"
 use "p" r x:1
 close "p"
 w !,x,!
 ;
 ; Make sure that the default index.html isn't returned
 k httpStatus,return
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55731/index.html")
 d CHKEQ^%ut(httpStatus,404)
 ;
 ; Make sure there is nothing in ^TMP("HTTPERR",$J)
 k ^TMP("HTTPERR")
 k httpStatus,return
 ; known invalid URL
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55731/asdf.html")
 d CHKEQ^%ut(httpStatus,404)
 d CHKEQ^%ut($d(^TMP("HTTPERR")),0)
 ;
 ; Make sure HTTP Listener status doesn't control anything
 d CHKEQ^%ut($d(^%webhttp(0,"listener")),0)
 s ^%webhttp(0,"listener")="stop"
 h .1
 k httpStatus,return
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55731/ping")
 d CHKEQ^%ut(httpStatus,200)
 ;
 ; Make sure ^%web(17.6001) isn't used
 k httpStatus,return
 d &libcurl.curl(.httpStatus,.return,"GET","http://127.0.0.1:55731/bigoutput")
 do CHKEQ^%ut(httpStatus,404)
 do CHKEQ^%ut($l(return),0)
 ;
 ; now stop the webserver again
 open "p":(command="$gtm_dist/mupip stop "_nogblJob)::"pipe"
 use "p" r x:1
 close "p"
 w !,x,!
 set ^%webhome=oldDir
 kill nogblJob
 quit
tStop ; @TEST Stop the Server. MUST BE LAST TEST HERE.
 do stop^%webreq
 quit
 ;
 ;
cov ; [Private: Calculate Coverage]
 n rtn,t1,t2 f i=1:1 s t1=$t(covlist+i),t2=$p(t1,";;",2) quit:t2=""  s rtn(t2)=""
 d RTNANAL^%ut1(.rtn,$na(^%wcohort))
 k ^%wsurv m ^%wsurv=^%wcohort
 d COVCOV^%ut1($na(^%wsurv),$na(^%wtrace)) ; Venn diagram matching between globals
 d COVRPT^%ut1($na(^%wcohort),$na(^%wsurv),$na(^%wtrace),2)
 quit
 ;
resetURLs ; Reset all the URLs; Called upon start-up
 d deleteService^%webutils("GET","r/{routine?.1""%25"".32AN}")
 d deleteService^%webutils("PUT","r/{routine?.1""%25"".32AN}")
 d deleteService^%webutils("GET","/test/error")
 d deleteService^%webutils("GET","bigoutput")
 d deleteService^%webutils("POST","rpc/{rpc}")
 d deleteService^%webutils("POST","/rpc2/{rpc}")
 ;
 do addService^%webutils("GET","r/{routine?.1""%25"".32AN}","R^%webapi")
 do addService^%webutils("PUT","r/{routine?.1""%25"".32AN}","PR^%webapi",1,"XUPROGMODE")
 do addService^%webutils("GET","/test/error","ERR^%webapi")
 do addService^%webutils("GET","bigoutput","bigoutput^%webapi")
 do addService^%webutils("POST","rpc/{rpc}","RPC^%webapi",1)
 n params s params(1)="U^rpc",params(2)="F^start",params(3)="F^direction",params(4)="B"
 n ien s ien=$$addService^%webutils("POST","/rpc2/{rpc}","rpc2^%webapi",1,"","",.params)
 quit
 ;
XTROU ;
 ;;%webjsonEncodeTest
 ;;%webjsonDecodeTest
 ;;
covlist ; Coverage List for ACTIVE (non-test) routines
 ;;%webreq
 ;;%webrsp
 ;;%webapi
 ;;%webhome
 ;;%webutils
 ;;%webjson
 ;;%webjsonDecode
 ;;%webjsonEncode
 ;;
EOR ;
 ;
 ; Copyright 2018-2019 Sam Habiel
 ; Copyright 2019 Christopher Edwards
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.

%webutils
%webutils ;SLC/KCM -- Utilities for HTTP communications ;2019-11-14  11:50 AM
 ;
UP(X) Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
LOW(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
 ;
LTRIM(%X) ; Trim whitespace from left side of string
 ; derived from XLFSTR, but also removes tabs
 N %L,%R
 S %L=1,%R=$L(%X)
 F %L=1:1:$L(%X) Q:$A($E(%X,%L))>32
 Q $E(%X,%L,%R)
 ;
URLENC(X) ; Encode a string for use in a URL
 ; Q $ZCONVERT(X,"O","URL")  ; uncomment for fastest performance on Cache
 ; =, &, %, +, non-printable 
 ; {, } added JC 7-24-2012
 N I,Y,Z,LAST
     S Y=$P(X,"%") F I=2:1:$L(X,"%") S Y=Y_"%25"_$P(X,"%",I)
 S X=Y,Y=$P(X,"&") F I=2:1:$L(X,"&") S Y=Y_"%26"_$P(X,"&",I)
 S X=Y,Y=$P(X,"=") F I=2:1:$L(X,"=") S Y=Y_"%3D"_$P(X,"=",I)
 S X=Y,Y=$P(X,"+") F I=2:1:$L(X,"+") S Y=Y_"%2B"_$P(X,"+",I)
 S X=Y,Y=$P(X,"{") F I=2:1:$L(X,"{") S Y=Y_"%7B"_$P(X,"{",I)
 S X=Y,Y=$P(X,"}") F I=2:1:$L(X,"}") S Y=Y_"%7D"_$P(X,"}",I)
 S Y=$TR(Y," ","+")
 S Z="",LAST=1
 F I=1:1:$L(Y) I $A(Y,I)<32 D
 . S CODE=$$DEC2HEX($A(Y,I)),CODE=$TR($J(CODE,2)," ","0")
 . S Z=Z_$E(Y,LAST,I-1)_"%"_CODE,LAST=I+1
 S Z=Z_$E(Y,LAST,$L(Y))
 Q Z
 ;
URLDEC(X,PATH) ; Decode a URL-encoded string
 ; Q $ZCONVERT(X,"I","URL")  ; uncomment for fastest performance on Cache
 ;
 N I,OUT,FRAG,ASC
 S:'$G(PATH) X=$TR(X,"+"," ") ; don't convert '+' in path fragment
 F I=1:1:$L(X,"%") D
 . I I=1 S OUT=$P(X,"%") Q
 . S FRAG=$P(X,"%",I),ASC=$E(FRAG,1,2),FRAG=$E(FRAG,3,$L(FRAG))
 . I $L(ASC) S OUT=OUT_$C($$HEX2DEC(ASC))
 . S OUT=OUT_FRAG
 Q OUT
 ;
REFSIZE(ROOT) ; return the size of glvn passed in ROOT
 Q:'$D(ROOT) 0 Q:'$L(ROOT) 0
 Q:$G(ROOT)="" 0
 N SIZE,I
 S SIZE=0
 S ROOT=$NA(@ROOT)
 I $P($SY,",")=47 G REFSIZEGTM
 I $D(@ROOT)#2 S SIZE=$L(@ROOT)
 ; I $D(@ROOT)>1 S I=0 F  S I=$O(@ROOT@(I)) Q:'I  S SIZE=SIZE+$L(@ROOT@(I))
 N ORIG,OL S ORIG=ROOT,OL=$QL(ROOT) ; Orig, Orig Length
 F  S ROOT=$Q(@ROOT) Q:ROOT=""  Q:($NA(@ROOT,OL)'=$NA(@ORIG,OL))  S SIZE=SIZE+$L(@ROOT)
 S ROOT=ORIG
 Q SIZE
 ;
REFSIZEGTM ; Refsize for GT.M/UTF-8
 I $D(@ROOT)#2 S SIZE=$ZL(@ROOT)
 ; I $D(@ROOT)>1 S I=0 F  S I=$O(@ROOT@(I)) Q:'I  S SIZE=SIZE+$L(@ROOT@(I))
 N ORIG,OL S ORIG=ROOT,OL=$QL(ROOT) ; Orig, Orig Length
 F  S ROOT=$Q(@ROOT) Q:ROOT=""  Q:($NA(@ROOT,OL)'=$NA(@ORIG,OL))  S SIZE=SIZE+$ZL(@ROOT)
 S ROOT=ORIG
 Q SIZE
 ;
VARSIZE(V) ; return the size of a variable
 Q:'$D(V) 0
 N SIZE,I
 S SIZE=0
 I $P($SY,",")=47 G VARSIZEGTM
 I $D(V)#2 S SIZE=$L(V)
 I $D(V)>1 S I="" F  S I=$O(V(I)) Q:'I  S SIZE=SIZE+$L(V(I))
 Q SIZE
 ;
VARSIZEGTM ; Varsize for GT.M/UTF-8
 I $D(V)#2 S SIZE=$ZL(V)
 I $D(V)>1 S I="" F  S I=$O(V(I)) Q:'I  S SIZE=SIZE+$ZL(V(I))
 Q SIZE
 ;
setError(ERRCODE,MESSAGE,ERRARRAY) G setError1
SETERROR(ERRCODE,MESSAGE,ERRARRAY) ; set error info into ^TMP("HTTPERR",$J)
setError1 ;
 ; causes HTTPERR system variable to be set
 ; ERRCODE:  query errors are 100-199, update errors are 200-299, M errors are 500
 ; MESSAGE:  additional explanatory material
 ; ERRARRAY: An Array to use instead of the Message for information to the user.
 ;
 N NEXTERR,ERRNAME,TOPMSG
 S HTTPERR=400,TOPMSG="Bad Request"
 ; query errors (100-199)
 I ERRCODE=101 S ERRNAME="Missing name of index"
 I ERRCODE=102 S ERRNAME="Invalid index name"
 I ERRCODE=103 S ERRNAME="Parameter error"
 I ERRCODE=104 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Bad key"
 I ERRCODE=105 S ERRNAME="Template required"
 I ERRCODE=106 S ERRNAME="Bad Filter Parameter"
 I ERRCODE=107 S ERRNAME="Unsupported Field Name"
 I ERRCODE=108 S ERRNAME="Bad Order Parameter"
 I ERRCODE=109 S ERRNAME="Operation not supported with this index"
 I ERRCODE=110 S ERRNAME="Order field unknown"
 I ERRCODE=111 S ERRNAME="Unrecognized parameter"
 I ERRCODE=112 S ERRNAME="Filter required"
 ; update errors (200-299)
 I ERRCODE=201 S ERRNAME="Unable to encode JSON"
 I ERRCODE=202 S ERRNAME="Unable to decode JSON"
 I ERRCODE=203 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Unable to determine patient"
 I ERRCODE=204 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Unable to determine collection" ; unused?
 I ERRCODE=205 S ERRNAME="Patient mismatch with object"
 I ERRCODE=207 S ERRNAME="Missing UID"
 I ERRCODE=209 S ERRNAME="Missing range or index" ; unused?
 I ERRCODE=210 S ERRNAME="Unknown UID format"
 I ERRCODE=211 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Missing patient identifiers"
 I ERRCODE=212 S ERRNAME="Mismatch of patient identifiers"
 I ERRCODE=213 S ERRNAME="Delete demographics only not allowed"
 I ERRCODE=214 S HTTPERR=404,ERRNAME="Patient ID not found in database"
 I ERRCODE=215 S ERRNAME="Missing collection name"
 I ERRCODE=216 S ERRNAME="Incomplete deletion of collection"
 ; Generic Errors
 I ERRCODE=301 S ERRNAME="Required variable undefined"
 ; HTTP errors
 I ERRCODE=400 S ERRNAME="Bad Request"
 I ERRCODE=401 S ERRNAME="Unauthorized" ; VEN/SMH
 I ERRCODE=404 S ERRNAME="Not Found"
 I ERRCODE=405 S ERRNAME="Method Not Allowed"
 ; system errors (500-599)
 I ERRCODE=501 S ERRNAME="M execution error"
 I ERRCODE=502 S ERRNAME="Unable to lock record"
 I '$L($G(ERRNAME)) S ERRNAME="Unknown error"
 ;
 I ERRCODE>500 S HTTPERR=500,TOPMSG="Internal Server Error"  ; M Server Error
 I ERRCODE<500,ERRCODE>400 S HTTPERR=ERRCODE,TOPMSG=ERRNAME  ; Other HTTP Errors
 Q:$G(NOGBL)
 S NEXTERR=$G(^TMP("HTTPERR",$J,0),0)+1,^TMP("HTTPERR",$J,0)=NEXTERR
 S ^TMP("HTTPERR",$J,1,"apiVersion")="1.0"
 S ^TMP("HTTPERR",$J,1,"error","code")=HTTPERR
 S ^TMP("HTTPERR",$J,1,"error","message")=TOPMSG
 S ^TMP("HTTPERR",$J,1,"error","request")=$G(HTTPREQ("method"))_" "_$G(HTTPREQ("path"))_" "_$G(HTTPREQ("query"))
 I $D(ERRARRAY) M ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR)=ERRARRAY  ; VEN/SMH
 E  S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"reason")=ERRCODE
 E  S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"message")=ERRNAME
 I $L($G(MESSAGE)) S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"domain")=MESSAGE
 Q
customError(ERRCODE,ERRARRAY) ; set custom error into ^TMP("HTTPERR",$J)
 K ^TMP("HTTPERR",$J)
 S HTTPERR=ERRCODE
 M ^TMP("HTTPERR",$J,1)=ERRARRAY
 QUIT
 ;
 ; Cache specific functions (selected one support GT.M too!)
 ;
GMT() ; return HTTP date string (this is really using UTC instead of GMT)
 N TM,DAY
 I $$UP($ZV)["CACHE" D  Q $P(DAY," ")_", "_$ZDATETIME(TM,2)_" GMT"
 . S TM=$ZTIMESTAMP,DAY=$ZDATETIME(TM,11)
 ;
 N OUT
 I $$UP($ZV)["GT.M" D  Q OUT
 . N D S D="datetimepipe"
 . N OLDIO S OLDIO=$I
 . O D:(shell="/bin/sh":comm="date -u +'%a, %d %b %Y %H:%M:%S %Z'|sed 's/UTC/GMT/g'")::"pipe"
 . U D R OUT:1 
 . U OLDIO C D
 ;
 QUIT "UNIMPLEMENTED"
 ;
 ;
DEC2HEX(NUM) ; return a decimal number as hex
 Q $$BASE(NUM,10,16)
 ;Q $ZHEX(NUM)
 ;
HEX2DEC(HEX) ; return a hex number as decimal
 Q $$BASE(HEX,16,10)
 ;Q $ZHEX(HEX_"H")
 ;
BASE(%X1,%X2,%X3) ;Convert %X1 from %X2 base to %X3 base
 I (%X2<2)!(%X2>16)!(%X3<2)!(%X3>16) Q -1
 Q $$CNV($$DEC(%X1,%X2),%X3)
DEC(N,B) ;Cnv N from B to 10
 Q:B=10 N N I,Y S Y=0
 F I=1:1:$L(N) S Y=Y*B+($F("0123456789ABCDEF",$E(N,I))-2)
 Q Y
CNV(N,B) ;Cnv N from 10 to B
 Q:B=10 N N I,Y S Y=""
 F I=1:1 S Y=$E("0123456789ABCDEF",N#B+1)_Y,N=N\B Q:N<1
 Q Y
 ;
HTFM(%H,%F) ;$H to FM, %F=1 for date only
 N X,%,%T,%Y,%M,%D S:'$D(%F) %F=0
 I $$HR(%H) Q -1 ;Check Range
 I '%F,%H[",0" S %H=(%H-1)_",86400"
 D YMD S:%T&('%F) X=X_%T
 Q X
YMD ;21608 = 28 feb 1900, 94657 = 28 feb 2100, 141 $H base year
 S %=(%H>21608)+(%H>94657)+%H-.1,%Y=%\365.25+141,%=%#365.25\1
 S %D=%+306#(%Y#4=0+365)#153#61#31+1,%M=%-%D\29+1
 S X=%Y_"00"+%M_"00"+%D,%=$P(%H,",",2)
 S %T=%#60/100+(%#3600\60)/100+(%\3600)/100 S:'%T %T=".0"
 Q
HR(%V) ;Check $H in valid range
 Q (%V<2)!(%V>99999)
 ;
HTE(%H,%F) ;$H to external
 Q:$$HR(%H) %H ;Range Check
 N Y,%T,%R
 S %F=$G(%F,1) S Y=$$HTFM(%H,0)
T2 S %T="."_$E($P(Y,".",2)_"000000",1,7)
 D FMT Q %R
FMT ;
 N %G S %G=+%F
 G F1:%G=1,F2:%G=2,F3:%G=3,F4:%G=4,F5:%G=5,F6:%G=6,F7:%G=7,F8:%G=8,F9:%G=9,F1
 Q
 ;
F1 ;Apr 10, 2002
 S %R=$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_$S($E(Y,6,7):$E(Y,6,7)_", ",1:"")_($E(Y,1,3)+1700)
 ;
TM ;All formats come here to format Time.
 N %,%S Q:%T'>0!(%F["D")
 I %F'["P" S %R=%R_"@"_$E(%T,2,3)_":"_$E(%T,4,5)_$S(%F["M":"",$E(%T,6,7)!(%F["S"):":"_$E(%T,6,7),1:"")
 I %F["P" D
 . S %R=%R_" "_$S($E(%T,2,3)>12:$E(%T,2,3)-12,+$E(%T,2,3)=0:"12",1:+$E(%T,2,3))_":"_$E(%T,4,5)_$S(%F["M":"",$E(%T,6,7)!(%F["S"):":"_$E(%T,6,7),1:"")
 . S %R=%R_$S($E(%T,2,7)<120000:" am",$E(%T,2,3)=24:" am",1:" pm")
 . Q
 Q
 ;Return Month names
M() Q "  Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec"
 ;
F2 ;4/10/02
 S %R=$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)_"/"_$E(Y,2,3)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F3 ;10/4/02
 S %R=$J(+$E(Y,6,7),2)_"/"_$J(+$E(Y,4,5),2)_"/"_$E(Y,2,3)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F4 ;02/4/10
 S %R=$E(Y,2,3)_"/"_$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F5 ;4/10/2002
 S %R=$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)_"/"_($E(Y,1,3)+1700)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F6 ;10/4/2002
 S %R=$J(+$E(Y,6,7),2)_"/"_$J(+$E(Y,4,5),2)_"/"_($E(Y,1,3)+1700)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F7 ;2002/4/10
 S %R=($E(Y,1,3)+1700)_"/"_$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F8 ;10 Apr 02
 S %R=$S($E(Y,6,7):$E(Y,6,7)_" ",1:"")_$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_$E(Y,2,3)
 G TM
F9 ;10 Apr 2002
 S %R=$S($E(Y,6,7):$E(Y,6,7)_" ",1:"")_$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_($E(Y,1,3)+1700)
 G TM
 ;
PARSE10(BODY,PARSED) ; Parse BODY by CRLF and return the array in PARSED
 ; Input: BODY: By Ref - BODY to be parsed
 ; Output: PARSED: By Ref - PARSED Output
 ; E.g. if BODY is ABC_CRLF_DEF_CRLF, PARSED is PARSED(1)="ABC",PARSED(2)="DEF",PARSED(3)=""
 N LL S LL="" ; Last line
 N L S L=1 ; Line counter.
 K PARSED ; Kill return array
 N I S I="" F  S I=$O(BODY(I)) Q:'I  D  ; For each 4000 character block
 . N J F J=1:1:$L(BODY(I),$C(10)) D  ; For each line
 . . S:(J=1&(L>1)) L=L-1 ; Replace old line (see 2 lines below)
 . . S PARSED(L)=$TR($P(BODY(I),$C(10),J),$C(13)) ; Get line; Take CR out if there.
 . . S:(J=1&(L>1)) PARSED(L)=LL_PARSED(L) ; If first line, append the last line before it and replace it.
 . . S LL=PARSED(L) ; Set last line
 . . S L=L+1 ; LineNumber++
 QUIT
 ;
ADDCRLF(RESULT) ; Add CRLF to each line
 I $E($G(RESULT))="^" D  QUIT  ; Global
 . N V,QL S V=RESULT,QL=$QL(V) F  S V=$Q(@V) Q:V=""  Q:$NA(@V,QL)'=RESULT  S @V=@V_$C(13,10)
 E  D  ; Local variable passed by reference
 . I $D(RESULT)#2 S RESULT=RESULT_$C(13,10)
 . N V S V=$NA(RESULT) F  S V=$Q(@V) Q:V=""  S @V=@V_$C(13,10)
 QUIT
 ;
UNKARGS(ARGS,LIST) ; returns true if any argument is unknown
 N X,UNKNOWN
 S UNKNOWN=0,LIST=","_LIST_","
 S X="" F  S X=$O(ARGS(X)) Q:X=""  I LIST'[(","_X_",") D
 . S UNKNOWN=1
 . D SETERROR^VPRJRUT(111,X)
 Q UNKNOWN
 ;
ENCODE64(X) ;
 N RGZ,RGZ1,RGZ2,RGZ3,RGZ4,RGZ5,RGZ6
 S RGZ=$$INIT64,RGZ1=""
 F RGZ2=1:3:$L(X) D
 .S RGZ3=0,RGZ6=""
 .F RGZ4=0:1:2 D
 ..S RGZ5=$A(X,RGZ2+RGZ4),RGZ3=RGZ3*256+$S(RGZ5<0:0,1:RGZ5)
 .F RGZ4=1:1:4 S RGZ6=$E(RGZ,RGZ3#64+2)_RGZ6,RGZ3=RGZ3\64
 .S RGZ1=RGZ1_RGZ6
 S RGZ2=$L(X)#3
 S:RGZ2 RGZ3=$L(RGZ1),$E(RGZ1,RGZ3-2+RGZ2,RGZ3)=$E("==",RGZ2,2)
 Q RGZ1
DECODE64(X) ;
 N RGZ,RGZ1,RGZ2,RGZ3,RGZ4,RGZ5,RGZ6
 S RGZ=$$INIT64,RGZ1=""
 F RGZ2=1:4:$L(X) D
 .S RGZ3=0,RGZ6=""
 .F RGZ4=0:1:3 D
 ..S RGZ5=$F(RGZ,$E(X,RGZ2+RGZ4))-3
 ..S RGZ3=RGZ3*64+$S(RGZ5<0:0,1:RGZ5)
 .F RGZ4=0:1:2 S RGZ6=$C(RGZ3#256)_RGZ6,RGZ3=RGZ3\256
 .S RGZ1=RGZ1_RGZ6
 Q $E(RGZ1,1,$L(RGZ1)-$L(X,"=")+1)
INIT64() Q "=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
 ;
addService(method,urlPattern,routine,auth,authKey,authOption,params) ; [Public: Add Service Entry Point]
 ; pass all by value except params by ref
 ; do or $$; return if $$ is 0 for failure and ien for success
 ; param format:
 ; - param(1)="U^rpc" URL Component named RPC
 ; - param(2)="F^start" Form Body variable called start
 ; - param(3)="Q^dir" HTTP Query variable called dir
 ; - param(4)="B"     Pass the body
 set method=$get(method)
 set urlPattern=$get(urlPattern)
 set routine=$get(routine)
 ;
 ; validate method
 if "^GET^POST^PUT^OPTIONS^DELETE^TRACE^HEAD^CONNECT^"'["^"_method_"^" quit:$q 0 q
 ;
 ; if urlPattern or routine are empty, bad call
 if urlPattern=""!(routine="") quit:$q 0 q
 ;
 ; Remove leading slashes
 if $e(urlPattern)="/" s $e(urlPattern)=""
 ;
 ; Lock for edits
 if $P($SY,",")=47 tstart ():serial
 else  lock +^%webutils:1 else  quit:$q 0 q
 ;
 ; does it already exist; or add new entry
 new ien
 if $data(^%web(17.6001,"B",method,urlPattern)) do
 . new routine set routine=$order(^%web(17.6001,"B",method,urlPattern,""))
 . set ien=$order(^%web(17.6001,"B",method,urlPattern,routine,0))
 . kill ^%web(17.6001,"B",method,urlPattern)
 . set $piece(^%web(17.6001,0),"^",3)=ien
 else  do 
 . set ien=$o(^%web(17.6001," "),-1)+1
 . set $piece(^%web(17.6001,0),"^",3,4)=ien_"^"_ien
 ;
 ; now add the entry at this ien
 ; kill old one first
 kill ^%web(17.6001,ien)
 ;
 ; Add new one
 set ^%web(17.6001,ien,0)=method
 set ^%web(17.6001,ien,1)=urlPattern
 set ^%web(17.6001,ien,2)=routine
 set ^%web(17.6001,"B",method,urlPattern,routine,ien)=""
 ;
 ; Add Auth nodes
 if $text(^XUS)'="" do
 . if $g(auth)           set $piece(^%web(17.6001,ien,"AUTH"),"^",1)=1
 . if $g(authKey)'=""    set $piece(^%web(17.6001,ien,"AUTH"),"^",2)=$$FIND1^DIC(19.1,,"QX",authKey,"B")
 . if $g(authOption)'="" set $piece(^%web(17.6001,ien,"AUTH"),"^",3)=$$FIND1^DIC(19,,"QX",authOption,"B")
 ;
 ; Add Params
 if $order(params("")) do
 . new n for n=0:0 set n=$order(params(n)) quit:'n  set ^%web(17.6001,ien,"PARAMS",n,0)=params(n)
 . new lastn s lastn=+$order(params(""),-1)
 . set ^%web(17.6001,ien,"PARAMS",0)="^17.60012S^"_lastn_"^"_lastn
 ;
 ; Commit our changes and unlock
 if $P($SY,",")=47 tcommit
 else  lock -^%webutils
 ;
 ; Return IEN
 quit:$quit ien quit
 ;
deleteService(method,urlPattern) ; [Public: Delete Service]
 set method=$get(method)
 set urlPattern=$get(urlPattern)
 if method="" quit
 if urlPattern="" quit
 ;
 ; Remove leading slashes
 if $e(urlPattern)="/" s $e(urlPattern)=""
 ;
 new ien
 if $P($SY,",")=47 tstart ():serial
 if $data(^%web(17.6001,"B",method,urlPattern)) do
 . new routine set routine=$order(^%web(17.6001,"B",method,urlPattern,""))
 . set ien=$order(^%web(17.6001,"B",method,urlPattern,routine,0))
 . kill ^%web(17.6001,"B",method,urlPattern)
 . kill ^%web(17.6001,ien)
 . set $piece(^%web(17.6001,0),"^",3)=ien
 . set $piece(^%web(17.6001,0),"^",4)=$piece(^%web(17.6001,0),"^",4)-1
 if $P($SY,",")=47 tcommit
 ;
 quit
 ;
 ; Portions of this code are public domain, but it was extensively modified
 ; Copyright 2013-2019 Sam Habiel
 ;
 ;Licensed under the Apache License, Version 2.0 (the "License");
 ;you may not use this file except in compliance with the License.
 ;You may obtain a copy of the License at
 ;
 ;    http://www.apache.org/licenses/LICENSE-2.0
 ;
 ;Unless required by applicable law or agreed to in writing, software
 ;distributed under the License is distributed on an "AS IS" BASIS,
 ;WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ;See the License for the specific language governing permissions and
 ;limitations under the License.



